/* * Lite Publisher
* Copyright (C) 2010, 2012 Vladimir Yushko http://litepublisher.com/
* Dual licensed under the MIT (mit.txt)
* and GPL (gpl.txt) licenses.

Содержание:
1. Об этом документе
2. Формат about.ini
3 . О наследовании шаблонов и родительских темах
4. О формате файла темы
5. Описание тегов и шаблонов
6. Дополнительные шаблоны $custom

1. Этот файл является одновременно документацией и набором шаблонов темы CMS LitePublisher. В этом файле описываются и устанавливаются все шаблоны темы. 

2. Формат about.ini. Разборщик шаблонов начинает свой анализ с файла about.ini в папке темы. Файл about.ini обязан присутствовать в каждой теме LitePublisher, в котором обязана быть секция [about] со следующими обязательными параметрами:

name - название темы, как правило совпадает с именем папки
type - тип темы, для 4 версии это значение  litepublisher4, в предыдущих версиях он отсутствует, необходим для обратной совместимости с темами 3.xx версий
file - имя файла с шаблонами в этой же папке, может быть любым, в теме по умолчанию это theme.txt
version - версия темы, например 4.0
author - имя разработчика темы
url адрес сайта разработчика темы
description- описание темы.

Описанные параметры являются обязательными. К необязательным параметрам относятся:
parent - имя родительской темы (имя папки в общей папке тем themes)
screenshot - имя файла скриншота, если отсутствует, то скриншот должен находится в файле screenshot.png
sidebar0, sidebar1 - не обязательные названия сайдбаров для админки, например "Правая колонка", "Подвал"

Если в about.ini есть языковая секция, например на русском[ru] и сайт на русском, то секция [ru] перезаписывает значения из секции [about. ]. Кодировка файла about.ini - utf-8.

3 . О наследовании шаблонов и родительских темах. В LitePublisher есть мощный механизм наследования тем. Если у темы не задана ее родительская тема, то родительской темой является тема по умолчанию default. Имя родительской темы задается в файле about.ini секция [about] параметром parent. У темы по умолчанию нет родительской темы. В разборщике тем проверяется зацикливание тем, поэтому при разработке своей темы следите, чтобы цепочка дочерних тем не зацикливалась.

Таким образом получается цепочка дочерних шаблонов. Длина цепочки наследования неограничена. Единственное естественное условие - отсутствие зацикливания.

Наследование означает, что в новой теме уже заранее известны все шаблоны - они берутся из родительской темы и разработчику новой темы достаточно только прописать свои новые шаблоны. Шаблоны, которые совпадают с родительской темой, прописывать не нужно - именно для этого и сделано наследование, чтобы разгрузить от прописывания всех шаблонов.

4. О формате файла темы.
 Тема представляет собой набор вложенных друг в друга шаблонов, таким образом получается дерево шаблонов. Каждый из шаблонов - это готовый HTML код с тегами Litepublisher. Теги  LitePublisher - это выражения вида $object.property, где object - объект, а property - его свойство. Например $template.title или $template.content. Со списком всех доступных тегов вы можете ознакомится в документации.
 
 Примечание для разработчиков: разборщик темы преобразует файлы темы в ассоциативный массив с ключами из строк в виде полного пути к тегу и хранит их в таком виде. Получается, что тема "компилируется" и поэтому внесенные изменения в файлы темы немедленно никак не применяются. Это обеспечивает высокую производительность. Для разработки тем, чтобы немедленно видеть все внесенные изменения, следует установить плагин очистки кеша, которыый есть в дистрибутиве. После написания темы следует деинсталировать плагин.

В файле темы находятся объявления тегов и комментарии. Комментарии возможны только вне объявлений тегов и невозможны внутри тегов. Объявление тега выглядит следующим образом: $template.name =[ html тега $template.name] Перед $template могут быть только пробелы или строка сразу должна начинатся с $template., иначе строка пропускается как комментарий.Для всех тегов можно опускать $template. для сокращения имени тега. Вместо квадратных скобок [] могут использоваться либо круглые () ЛИБО ФИГУРНЫЕ{} скобки. Выбирать можно любые парные скобки, единственное условие - чтобы в тексте шаблона все открытые скобки закрывались. То есть если вы выбрали [], то текст шаблона должен закрыть все открытые в нем квадратные скобки.

О языковых строках внутри темы. Не все тексты могут находится в $lang.* движка и вы можете для своей темы задать небольшое количество строк в файле about.ini в языковых секциях. Парсер темы заменяет все теги $about.* на соответствующие ключи файла about.ini. Таким образом можно добится интернализации вашей темы.

На верхнем уровне иерархии шаблонов находятся всего несколько шаблонов:
$template - шаблон всей страницы целиком
$template.head - шаблоны для секции head
$template.title - шаблон заголовка страницы
$template.menu - список страниц меню
$template.content - содержание, включает все основные шаблоны
$template.sidebar - шаблон сайдбара и виджетов в нем

5. Описание тегов и шаблонов.
 Начнем декларировать шаблоны верхнего уровня, и в начале объявим шаблон всей страницы целиком: */

$template = {@import(index.tml)}

/* Это объявление означает, что шаблон находится в файле  index.tml - посмотрите его в той же папке, что и этот файл. Включать шаблон из файла можно двумя способами - как в этом примере @import(имя файла с шаблоном), и второй способ file=имя файла. Во втором случае объявление шаблона выглядело бы как $template = {file=index.tml} Какой способ выбрать остается на ваше усмотрение. Включаемые файлы могут находится только в папке темы и нигде больше. Вы можете любой из шаблонов сохранить в отдельный файл и включить его в тему директивой @import () или альтернативным способом file= В подключаемом файле тоже могут подключаться другие файлы. Уровень вложенности не ограничен. Нет проверки на зацикливание вложенных файлов - поэтому, пожалуйста, самостоятельно следите за подключаемыми файлами, а это не сложно. Комментарии в подключаемых файлах запрещены, они возможны только в главном файле, как здесь. Например вы можете указать, что сайдбар находится в файле sidebar.tml следующим образом: $template.sidebar = [file=sidebar.tml]. Подключать файл с шаблоном можно внутри обявления тега вместо html. 

Давайте откроем файл index.tml и посмотрим его текст - в нем находится шаблон всей страницы полностью. Следует заметить, что вэтом шаблоне отсутствуют какие либо вложенные шаблоны. Сделано это специально для демонстрации общей структуры темы на самом верхнем уровне. Можно немного поподробнее остановиться на каждом из тегов. Самым первым встречается тег $template.title - заголовок страницы. Установим шаблон для заголовка страницы следующим образом: */

$template.title = [$title $template.page | $site.name]

/* где 
$title - это например заголовок записи
$template.page - номер страницы, если страница первая, то пустая строка, иначе "страница #"
$site.name - название сайта в настройках

Обязательно надо сказать, что после применения шаблона все пробелы и символы | обрезаются покраям. Так что если один из тегов шаблона $template.title будет пустой строкой, то это не повредит конечному результату.

 Мы уже объявили два шаблона в теме - 	$template(шаблон всей страницы) и $template.title (заголовок страницы). Далее встречаются следующие теги, которые не являются шаблонами:
$template.url - адрес этой темы, используется чтобы указать адрес файлов темы. Нигде не декларируется, так как это не шаблон.
$template.head - стандартный html для секции HEAD HTML документа. Доступен ддля редактирования в админке вид/секция head
$site.url - адрес сайта, без слеша / в конце адреса
$site.files - адрес файлов на сайте, без слеша / в конце адреса. Используется для указания адреса файла на сайте, по умолчанию совпадает с адресом сайта $site.url
$site.name - название сайта
$site.description - описание сайта
$site.version - номер версии движка
$site.language - язык сайта, две буквы, для русского это - ru, для английского - en

Далее мы встречаем тег $template.menu - ЭТО СПИСОК МЕНЮ В ШАПКЕ САЙТА, ЗАДЕКЛАРИРУЕМ ШАБЛОН ДЛЯ ЭТОГО ТЕГА */

$template.menu = [
$hover = [true]
<script type="text/javascript">
  $(document).ready(function() {
    var menu = $("#nav");
    $("a[href='" + window.location + "']", menu).addClass("current_page_link");
    $("li", menu).mouseenter(function(){$(this).addClass("jshover");}).mouseleave(function(){$(this).removeClass("jshover");}); 
  });
</script>
	<ul id="nav">
		$item = [<li><a href="$link" title="$title">$title</a>$submenu = [ <ul>$items</ul>]</li>]
				$single = [<li><a href="$link" title="$title">$title</a></li>]
		$current = [		<li class="current_page_item"><a href="$link" title="$title">$title</a>$submenu</li>]
	</ul>
]

/* В шаблоне меню мы встретили теги:
$hover - указывает, поддерживает ли шаблон всплывающее меню . Может принимать 3 значения: bootstrap, true или false, по умолчанию = true и указывать не обязательно. Чтобы указать, что шаблон не поддерживает всплывающее меню необходимо указать $hover = [false]. Параметр $hover влияет только на то, каким образом движок будет генерировать список ссылок: при bootstrap и true будут вложенные списки (если bootstrap, то первым в подменю будет дублироваться родительская ссылка, так ак в фреймворке bootstrap меню верхнего уровня не открывает страницы), при false только одноуровневый список (то есть нет вложенных списков). За остальную поддержку эфектов всплывания меню обязан позаботиться разработчик темы. Существует много алгоритмов, как сделать всплывающее меню, какой из них предпочесть - остается на выбор разработчику темы. Для этой темы используются стили hover для списка, а для поддержки IE6 используется трюк со стилем jshover - его добавление/удаление как раз реализовано в jquery шаблона меню. Безусловно, логичнее было бы вставить javascript в секцию head шаблона целой страницы, но мы его поместили в шаблон меню исключительно для демонстрации, что именно этот javascript отвечает за поддержку эфектов всплывания.

$item - шаблон элемента списка, имеет вложенный шаблон $subitems - вложенный список
$single - шаблон одиночного меню в списке, не имеющего вложенного подменю. Важное примечание: если этот шаблон не указать, то будет использован предыдущий шаблон $item. Чтобы не возникли казусы с разработкой темы всегда декларируйте шаблон $single после шаблона $item. Если же шаблон $single совпадает с $item, то вовсе можно $single не декларировать. Исторически шаблон $single появился гораздо позже для поддержки шаблонов bootstrap, где отличаются шаблоны с подменю и без подменю.
$current - шаблон активной ссылки в списке. В настоящее время является устаревшим и не используется. Смотрите javascript поддержки всплывающего меню, в котором есть строка добавляющая класс к ссылки на текущую страницу.

В шаблоне $item доступны следующие теги:
$link - адрес страницы, включая адрес сайта
$url - адрес страницы меню, без адреса сайта
$TITLE - ЗАГОЛОВОК МЕНЮ
$ITEMS - ИСПОЛЬЗУЕТСЯ В ШАБЛОНЕ ПОДМЕНЮ $SUBMENU, КОТОРОЕ ГЕНЕРИРУЕТСЯ движком.

Про меню все. Объявим шаблоны для секции head, сразу сделав замечание, что эти шаблоны перекрываются редко и вам вряд ли понадобиться их перекрывать в новой теме. */

$template.head = [
  $post = [
    $rss = [<link rel="alternate" type="application/rss+xml" title="$lang.onpost $post.title" href="$post.rsscomments" />]
    $prev = [<link rel="prev" title="$prev.title" href="$prev.link" />]
    $next = [<link rel="next" title="$next.title" href="$next.link" />]
  ]
$tags = [<link rel="alternate" type="application/rss+xml" title="$context.title" href="$site.url/rss/$context.postpropname/$context.id.xml" />]
]

/* В шаблоне $template.head находится шаблоны для полной записи $post. В данном случае шабон пустой и включает в себя 3 подшаблона:
rss - ссылка на RSS комментариев к записи
prev - ссылка на предыдущую запись
next - ссылка на следующую запись

Если нет следующей или предыдущей записи, то секции head тоже не будет ссылок. Если комментарии закрыты или отсутствуют, то ссылки на RSS комментариев тоже не будет. Эти шаблоны используются в теге $post.head. Шаблон $tags предназначен для секции head рубрик и меток, в частности ссылка на RSS постов этой рубрики или метки. использовались теги $context.*, где $context - это текущий объект запроса и будет либо рубрики или метки. На страницах записи - это будет запись. На странице записи $context и $post одинаковы.

В версии litepublisher 5.73 были добавлены новые шаблоны $template.index.home, $template.index.post и $template.index.tag - шаблоны главной страницы, записи и рубрики/метки. Как правило к этим страницам предъявляются особые требования. В предыдущих версиях движка приходилось создавать отдельные темы для главной, записи и рубрик, что вызывало определенные неудобства во время разработки новой темы. По умолчанию особого шаблона у главной, записи и рубрик/меток нет, обявим эти шаблоны: */

$template.index.home = []
$template.index.post = []
$template.index.tag = []

/* Чтобы указать, что шаблон всей страницы для главной находится в файле home.tml можно сделать так: $template.index.home = {@import(home.tml)} Не забывайте поместить такое объявление сновой строки. Аналогично можно объявить и другие шаблоны. Дополнительно для главной смотрите шаблон content.home */

/* Перейдем к  следующему очень важному тегу - $template.content. В нем содержатся шаблоны контента сайта. Перечислим эти шаблоны:
simple - шаблон для простых текстов, не имеет вложенных шаблонов и состоит из одной - двух строк
notfound - шаблон для страницы 404, не  имеет вложеных шаблонов, похож на simple
menu - шаблон страницы меню, не имеет вложенных шаблонов. Применяется также для страниц меток и рубрик.
excerpts - шаблон для анонсов, включает в себя вложенные шаблоны
post - шаблон полной записи, включает в себя много шаблонов, в том числе комментарии и форму комментариев
navi  - шаблон ссылок для постраничной навигации, имеет вложенные шаблоны
author - шаблон для страницы автора, не имеет вложенных шаблонов. Применяется при многопользовательском режиме
admin - шаблоны для админки, имеет вложенные шаблоны

Перейдем к заданию шаблонов контента. Начнем с простого - шаблон simple, который отвечает за вывод простого контента */

$template.content.simple = [<div class="simplecontent">$content</div>]

/* Видим, что в этом шаблоне есть только одна переменная $content - в ней находится текст. Объявим еще один простой шаблон для страницы 404: */

$template.content.notfound = [
			<div class="simplecontent">
				<h2 class="center">$lang.notfound </h2>
				<p class="center">$lang.nocontent</p>
</div>
]

/* Здесь мы видим использование двух тегов $lang.notfound и $lang.nocontent - эти значения берутся из языковых файлов lib/languages/*.ini, $lang.* всегда доступны в любом шаблоне и позволяют теме быть интернациональной.

 Перейдем к относительно более сложному шаблону - страница меню, и можем опустить употребление $template. Объявление content.menu = [ и объявление $template.content.menu = [ абсолютно равнозначны, единственный смысл опускать $template лишь в сокращении записи. Пропускание $template не избавлляет от испобьзования символа $ во вложенных шаблонах. */

content.menu = [
			<div class="post" id="menu-$menu.id">
		        <h2>$menu.title</h2>
		        <div class="post-content">
					$menu.content
		        </div>
			</div>
]

