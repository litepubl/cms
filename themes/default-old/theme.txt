* Lite Publisher
* Copyright (C) 2010, 2012 Vladimir Yushko http://litepublisher.com/
* Dual licensed under the MIT (mit.txt)
* and GPL (gpl.txt) licenses.

Содержание:
1. Об этом документе
2. Формат about.ini
3 . О наследовании шаблонов и родительских темах
4. О формате файла темы
5. Описание тегов и шаблонов
6. Дополнительные шаблоны $custom

1. Этот файл является одновременно документацией и набором шаблонов темы CMS LitePublisher. В этом файле описываются и устанавливаются все шаблоны темы. 

2. Формат about.ini. Разборщик шаблонов начинает свой анализ с файла about.ini в папке темы. Файл about.ini обязан присутствовать в каждой теме LitePublisher, в котором обязана быть секция [about] со следующими обязательными параметрами:

name - название темы, как правило совпадает с именем папки
type - тип темы, для 4 версии это значение  litepublisher4, в предыдущих версиях он отсутствует, необходим для обратной совместимости с темами 3.xx версий
file - имя файла с шаблонами в этой же папке, может быть любым, в теме по умолчанию это theme.txt
version - версия темы, например 4.0
author - имя разработчика темы
url адрес сайта разработчика темы
description- описание темы.

Описанные параметры являются обязательными. К необязательным параметрам относятся:
parent - имя родительской темы (имя папки в общей папке тем themes)
screenshot - имя файла скриншота, если отсутствует, то скриншот должен находится в файле screenshot.png
sidebar0, sidebar1 - не обязательные названия сайдбаров для админки, например "Правая колонка", "Подвал"

Если в about.ini есть языковая секция, например на русском[ru] и сайт на русском, то секция [ru] перезаписывает значения из секции [about. ]. Кодировка файла about.ini - utf-8.

3 . О наследовании шаблонов и родительских темах. В LitePublisher есть мощный механизм наследования тем. Если у темы не задана ее родительская тема, то родительской темой является тема по умолчанию default. Имя родительской темы задается в файле about.ini секция [about] параметром parent. У темы по умолчанию нет родительской темы. В разборщике тем проверяется зацикливание тем, поэтому при разработке своей темы следите, чтобы цепочка дочерних тем не зацикливалась.

Таким образом получается цепочка дочерних шаблонов. Длина цепочки наследования неограничена. Единственное естественное условие - отсутствие зацикливания.

Наследование означает, что в новой теме уже заранее известны все шаблоны - они берутся из родительской темы и разработчику новой темы достаточно только прописать свои новые шаблоны. Шаблоны, которые совпадают с родительской темой, прописывать не нужно - именно для этого и сделано наследование, чтобы разгрузить от прописывания всех шаблонов.

4. О формате файла темы.
 Тема представляет собой набор вложенных друг в друга шаблонов, таким образом получается дерево шаблонов. Каждый из шаблонов - это готовый HTML код с тегами Litepublisher. Теги  LitePublisher - это выражения вида $object.property, где object - объект, а property - его свойство. Например $template.title или $template.content. Со списком всех доступных тегов вы можете ознакомится в документации.
 
 Примечание для разработчиков: разборщик темы преобразует файлы темы в ассоциативный массив с ключами из строк в виде полного пути к тегу и хранит их в таком виде. Получается, что тема "компилируется" и поэтому внесенные изменения в файлы темы немедленно никак не применяются. Это обеспечивает высокую производительность. Для разработки тем, чтобы немедленно видеть все внесенные изменения, следует установить плагин очистки кеша, которыый есть в дистрибутиве. После написания темы следует деинсталировать плагин.

В файле темы находятся объявления тегов и комментарии. Комментарии возможны только вне объявлений тегов и невозможны внутри тегов. Объявление тега выглядит следующим образом: $template.name =[ html тега $template.name] Перед $template могут быть только пробелы или строка сразу должна начинатся с $template., иначе строка пропускается как комментарий.Для всех тегов можно опускать $template. для сокращения имени тега. Вместо квадратных скобок [] могут использоваться либо круглые () ЛИБО ФИГУРНЫЕ{} скобки. Выбирать можно любые парные скобки, единственное условие - чтобы в тексте шаблона все открытые скобки закрывались. То есть если вы выбрали [], то текст шаблона должен закрыть все открытые в нем квадратные скобки.

О языковых строках внутри темы. Не все тексты могут находится в $lang.* движка и вы можете для своей темы задать небольшое количество строк в файле about.ini в языковых секциях. Парсер темы заменяет все теги $about.* на соответствующие ключи файла about.ini. Таким образом можно добится интернализации вашей темы.

На верхнем уровне иерархии шаблонов находятся всего несколько шаблонов:
$template - шаблон всей страницы целиком
$template.head - шаблоны для секции head
$template.title - шаблон заголовка страницы
$template.menu - список страниц меню
$template.content - содержание, включает все основные шаблоны
$template.sidebar - шаблон сайдбара и виджетов в нем

5. Описание тегов и шаблонов.
 Начнем декларировать шаблоны верхнего уровня, и в начале объявим шаблон всей страницы целиком:

$template = {@import(index.tml)}

Это объявление означает, что шаблон находится в файле  index.tml - посмотрите его в той же папке, что и этот файл. Включать шаблон из файла можно двумя способами - как в этом примере @import(имя файла с шаблоном), и второй способ file=имя файла. Во втором случае объявление шаблона выглядело бы как $template = {file=index.tml} Какой способ выбрать остается на ваше усмотрение. Включаемые файлы могут находится только в папке темы и нигде больше. Вы можете любой из шаблонов сохранить в отдельный файл и включить его в тему директивой @import () или альтернативным способом file= В подключаемом файле тоже могут подключаться другие файлы. Уровень вложенности не ограничен. Нет проверки на зацикливание вложенных файлов - поэтому, пожалуйста, самостоятельно следите за подключаемыми файлами, а это не сложно. Комментарии в подключаемых файлах запрещены, они возможны только в главном файле, как здесь. Например вы можете указать, что сайдбар находится в файле sidebar.tml следующим образом: $template.sidebar = [file=sidebar.tml]. Подключать файл с шаблоном можно внутри обявления тега вместо html. 

Давайте откроем файл index.tml и посмотрим его текст - в нем находится шаблон всей страницы полностью. Следует заметить, что вэтом шаблоне отсутствуют какие либо вложенные шаблоны. Сделано это специально для демонстрации общей структуры темы на самом верхнем уровне. Можно немного поподробнее остановиться на каждом из тегов. Самым первым встречается тег $template.title - заголовок страницы. Установим шаблон для заголовка страницы следующим образом:

$template.title = [$title $template.page | $site.name]

где 
$title - это например заголовок записи
$template.page - номер страницы, если страница первая, то пустая строка, иначе "страница #"
$site.name - название сайта в настройках

Обязательно надо сказать, что после применения шаблона все пробелы и символы | обрезаются покраям. Так что если один из тегов шаблона $template.title будет пустой строкой, то это не повредит конечному результату.

 Мы уже объявили два шаблона в теме - 	$template(шаблон всей страницы) и $template.title (заголовок страницы). Далее встречаются следующие теги, которые не являются шаблонами:
$template.url - адрес этой темы, используется чтобы указать адрес файлов темы. Нигде не декларируется, так как это не шаблон.
$template.head - стандартный html для секции HEAD HTML документа. Доступен ддля редактирования в админке вид/секция head
$site.url - адрес сайта, без слеша / в конце адреса
$site.files - адрес файлов на сайте, без слеша / в конце адреса. Используется для указания адреса файла на сайте, по умолчанию совпадает с адресом сайта $site.url
$site.name - название сайта
$site.description - описание сайта
$site.version - номер версии движка
$site.language - язык сайта, две буквы, для русского это - ru, для английского - en

Далее мы встречаем тег $template.menu - ЭТО СПИСОК МЕНЮ В ШАПКЕ САЙТА, ЗАДЕКЛАРИРУЕМ ШАБЛОН ДЛЯ ЭТОГО ТЕГА

$template.menu = [
$hover = [true]
<script type="text/javascript">
  $(document).ready(function() {
    var menu = $("#nav");
    $("a[href='" + window.location + "']", menu).addClass("current_page_link");
    $("li", menu).mouseenter(function(){$(this).addClass("jshover");}).mouseleave(function(){$(this).removeClass("jshover");}); 
  });
</script>
	<ul id="nav">
		$item = [<li><a href="$link" title="$title">$title</a>$submenu = [ <ul>$items</ul>]</li>]
				$single = [<li><a href="$link" title="$title">$title</a></li>]
		$current = [		<li class="current_page_item"><a href="$link" title="$title">$title</a>$submenu</li>]
	</ul>
]

В шаблоне меню мы встретили теги:
$hover - указывает, поддерживает ли шаблон всплывающее меню . Может принимать 3 значения: bootstrap, true или false, по умолчанию = true и указывать не обязательно. Чтобы указать, что шаблон не поддерживает всплывающее меню необходимо указать $hover = [false]. Параметр $hover влияет только на то, каким образом движок будет генерировать список ссылок: при bootstrap и true будут вложенные списки (если bootstrap, то первым в подменю будет дублироваться родительская ссылка, так ак в фреймворке bootstrap меню верхнего уровня не открывает страницы), при false только одноуровневый список (то есть нет вложенных списков). За остальную поддержку эфектов всплывания меню обязан позаботиться разработчик темы. Существует много алгоритмов, как сделать всплывающее меню, какой из них предпочесть - остается на выбор разработчику темы. Для этой темы используются стили hover для списка, а для поддержки IE6 используется трюк со стилем jshover - его добавление/удаление как раз реализовано в jquery шаблона меню. Безусловно, логичнее было бы вставить javascript в секцию head шаблона целой страницы, но мы его поместили в шаблон меню исключительно для демонстрации, что именно этот javascript отвечает за поддержку эфектов всплывания.

$item - шаблон элемента списка, имеет вложенный шаблон $subitems - вложенный список
$single - шаблон одиночного меню в списке, не имеющего вложенного подменю. Важное примечание: если этот шаблон не указать, то будет использован предыдущий шаблон $item. Чтобы не возникли казусы с разработкой темы всегда декларируйте шаблон $single после шаблона $item. Если же шаблон $single совпадает с $item, то вовсе можно $single не декларировать. Исторически шаблон $single появился гораздо позже для поддержки шаблонов bootstrap, где отличаются шаблоны с подменю и без подменю.
$current - шаблон активной ссылки в списке. В настоящее время является устаревшим и не используется. Смотрите javascript поддержки всплывающего меню, в котором есть строка добавляющая класс к ссылки на текущую страницу.

В шаблоне $item доступны следующие теги:
$link - адрес страницы, включая адрес сайта
$url - адрес страницы меню, без адреса сайта
$TITLE - ЗАГОЛОВОК МЕНЮ
$ITEMS - ИСПОЛЬЗУЕТСЯ В ШАБЛОНЕ ПОДМЕНЮ $SUBMENU, КОТОРОЕ ГЕНЕРИРУЕТСЯ движком.

Про меню все. Объявим шаблоны для секции head, сразу сделав замечание, что эти шаблоны перекрываются редко и вам вряд ли понадобиться их перекрывать в новой теме.

$template.head = [
  $post = [
    $rss = [<link rel="alternate" type="application/rss+xml" title="$lang.onpost $post.title" href="$post.rsscomments" />]
    $prev = [<link rel="prev" title="$prev.title" href="$prev.link" />]
    $next = [<link rel="next" title="$next.title" href="$next.link" />]
  ]
$tags = [<link rel="alternate" type="application/rss+xml" title="$context.title" href="$site.url/rss/$context.postpropname/$context.id.xml" />]
$home = []
]

В шаблоне $template.head находится шаблоны для полной записи $post. В данном случае шабон пустой и включает в себя 3 подшаблона:
rss - ссылка на RSS комментариев к записи
prev - ссылка на предыдущую запись
next - ссылка на следующую запись

Если нет следующей или предыдущей записи, то секции head тоже не будет ссылок. Если комментарии закрыты или отсутствуют, то ссылки на RSS комментариев тоже не будет. Эти шаблоны используются в теге $post.head. Шаблон $tags предназначен для секции head рубрик и меток, в частности ссылка на RSS постов этой рубрики или метки. использовались теги $context.*, где $context - это текущий объект запроса и будет либо рубрики или метки. На страницах записи - это будет запись. На странице записи $context и $post одинаковы.

В версии litepublisher 5.73 были добавлены новые шаблоны $template.index.home, $template.index.post и $template.index.tag - шаблоны главной страницы, записи и рубрики/метки. Как правило к этим страницам предъявляются особые требования. В предыдущих версиях движка приходилось создавать отдельные темы для главной, записи и рубрик, что вызывало определенные неудобства во время разработки новой темы. По умолчанию особого шаблона у главной, записи и рубрик/меток нет, обявим эти шаблоны:

$template.index.home = []
$template.index.post = []
$template.index.tag = []

Чтобы указать, что шаблон всей страницы для главной находится в файле home.tml можно сделать так: $template.index.home = {@import(home.tml)} Не забывайте поместить такое объявление сновой строки. Аналогично можно объявить и другие шаблоны. Дополнительно для главной смотрите шаблон content.home

Перейдем к  следующему очень важному тегу - $template.content. В нем содержатся шаблоны контента сайта. Перечислим эти шаблоны:
simple - шаблон для простых текстов, не имеет вложенных шаблонов и состоит из одной - двух строк
notfound - шаблон для страницы 404, не  имеет вложеных шаблонов, похож на simple
menu - шаблон страницы меню, не имеет вложенных шаблонов. Применяется также для странц меток и рубрик.
excerpts - шаблон для анонсов, включает в себя вложенные шаблоны
post - шаблон полной записи, включает в себя много шаблонов, в том числе комментарии и форму комментариев
navi  - шаблон ссылок для постраничной навигации, имеет вложенные шаблоны
author - шаблон для страницы автора, не имеет вложенных шаблонов. Применяется при многопользовательском режиме
admin - шаблоны для админки, имеет вложенные шаблоны

Перейдем к заданию шаблонов контента. Начнем с простого - шаблон simple, который отвечает за вывод простого контента

	$template.content.simple = [<div class="simplecontent">$content</div>]

Видим, что в этом шаблоне есть только одна переменная $content - в ней находится текст. Объявим еще один простой шаблон для страницы 404:

$template.content.notfound = [
			<div class="simplecontent">
				<h2 class="center">$lang.notfound </h2>
				<p class="center">$lang.nocontent</p>
</div>
]

Здесь мы видим использование двух тегов $lang.notfound и $lang.nocontent - эти значения берутся из языковых файлов lib/languages/*.ini, $lang.* всегда доступны в любом шаблоне и позволяют теме быть интернациональной.

 Перейдем к относительно более сложному шаблону - страница меню, и можем опустить употребление $template. Объявление content.menu = [ и объявление $template.content.menu = [ абсолютно равнозначны, единственный смысл опускать $template лишь в сокращении записи. Пропускание $template не избавлляет от испобьзования символа $ во вложенных шаблонах.

content.menu = [
			<div class="post" id="menu-$menu.id">
		        <h2>$menu.title</h2>
		        <div class="post-content">
					$menu.content
		        </div>
			</div>
]

В этом шаблоне мы видим использование тегов $menu.*, а именно

$menu.id - уникальный id (число) меню
$menu.title - заголовок меню
$menu.content - текст страницы меню

у $menu есть и другие свойства, которые не использовались в этом шаблоне, например $menu.url, $menu.parent

Следующим, несколько усложненным шаблоном меню, можно назвать шаблон страницы автора:
content.author = [
			<div class="post" id="author-$author.id">
		        <h2>$author.title</h2>
		        <div class="post-content">
					$author.content
		        </div>
			</div>
]

В шаблоне использованы теги $author.*, расскажем о каждом из нихх:

$author.id - уникальный id (целое число) автора, равно $post.id
$author.name - имя автора
$author.title  - имя автора, синоним $author.name
$author.url - адрес страницы автора на вашем сайте, полный адрес будет если вначале прибавить $site.url
$author.website - адрес сайта автора
$author.email - почтовый ящик автора, конечно, лучше не публиковать
$author.md5email - строка md5 почтового ящика, можно использовать для аватара
$author.gravatar - html картинка аватара автора с сайта http://www.gravatar.com/
$author.keywords - ключевые слова страницы автора, используется в мета теге keywords
$author.description описание страницы автора, используется в мета теге description
$author.content - текст на странице автора

В версии движка 5.73 был добавлен новый шаблон content.home для главной страницы. В проекте интернет магазинов этот шаблон используется для верстки карусели между текстом и анонсами.

content.home= [
$midle = [
$post = []
]]

Внутри content.home мы видим пока только один вложенный шаблон - $midle, который используется если в настройках главной страницы (в админке Настройки/Главная) поставить галочку "Показывать дополнительные анонсы между текстом и основными анонсами" и будет выбрана рубрика в для этого. В $midle мы встречаем шаблон $post - шаблон анонса записи. Внутри шаблона content.home.midle.post можно использовать любые теги $post.*


Теперь можно переходить к более сложным шаблонам, каковым является шаблон записи. Можно объявить этот шаблон целиком со всеми вложенными шаблонами (формат файла темы это позволяет), но тогда будет сложнее комментировать каждый из шаблонов, поэтому постараемся обойтись минимумом вложенных шаблонов. Начнем:

content.post = [
			<div class="post" id="post-$post.id">
		        <h2><a href="$post.link" rel="bookmark" title="$lang.permalink $post.title">$post.iconlink$post.title</a></h2>
					<span class="post-date date">$post.date</span>
					<span class="post-tags">$post.taglinks</span>
						<div class="post-content">
       $post.filelist
							$post.content
							<div class="post-info">
								$post.rsslink
								<span class="post-cat">$post.catlinks</span>	
							</div>
							$post.prevnext
						</div>
      $post.templatecomments
			</div>
]

Таким образом мы смогли объявить шаблон для записи обойдясь вообще без вложенных шаблонов. В шаблоне записи используется свойства обекта $post, рассмотрим их:

$post.id - уникальный id (число) записи
$post.link- полный адрес записи, включая адрес сайта
$lang.permalink - переведенная строка "постоянная ссылка на"
$post.title - заголовок записи
$post.iconlink - html ссылка на иконку, если есть
$post.date - отформатированная и переведенная дата публикации поста. о формате и шаблоне даты читайте ниже
$post.taglinks - ссылки на метки записи, для них есть свой шаблон
$post.filelist - список файлов записи, длясписка есть свой шаблон
$post.content - текст записи
$post.catlinks - ссылки на рубрики записи, тоже можно задать шаблон
$post.rsslink - html ссылка на rss комментариев к записи, есть для этого тоже шаблон				$post.prevnext - ссылки на следующую и предыдущую запись, можно задать для этих ссылок шаблон
$post.templatecomments - выводит список комментариев и форму для отправки комментария. имеет много вложенных шаблонов.

Дополнительно приведу еще список тегов записи, могущих оказаться полезными при разработке темы:
$post.day - день (01-31) публикации
$post.month - месяц, краткое название (Несколько букв)
$post.year - год публикации, 4 цифры
$post.bookmark - html ссылка на запись, для этого внутри движка используется шаблон:
 <a href="$post.link" rel="bookmark" title="$lang.permalink $post.title">$post.iconlink$post.title</a>

$post.pubdate - дата публикации в формате пригодным для RSS
$post.excerptdate - отформатированная дата публикации для анонса. Про дополнительные тегидля анонсов будет рассказано когда будем рассматривать шаблоны для анонса.
$post.excerptcatlinks - ссылки категорий в анонсе, шаблон задается в секции шаблонов анонса
$post.excerpttaglinks - ссылки меток в анонсе, шаблон задается в секции шаблонов анонса
$post.excerptfilelist - список файлов, используется шаблон для анонсов
$post.firstimage - первая картинка в записи, если есть. Используется в анонсах, чтобы не показывать остальные картинки
$post.excerptcontent - текст анонса вместе со ссылкой "Далее"
$post.tagnames - метки, перечисленные через запятую, без ссылок, только названия
$post.catnames -рубрики, перечисленные через запятую, без ссылок, только названия
$post.head - html для секции head
$post.keywords - ключевые слова, по умолчанию равны меткам
$post.description - описание записи, по умолчанию это обрезанный анонс
$post.moretitle - текст для ссылки "Далее"  в анонсе
$post.morelink - ссылка "Далее" в анонсе
$post.title2 - альтернативный заголовок записи, обычно это пустая строка
$post.rss - текст записи в ленте RSS
$post.commentscount - количество комментариев к записи
$post.commentslink - html ссылка на комментарии к записи
$post.iconurl - адрес иконки, если она есть
$post.idurl - уникальный id адреса поста, в шаблонах неиспользуется
$post.parent - уникальный id родительского поста, по умолчанию = 0, нигде не используется, может быть пригодится в будущем
$post.revision - номер ревизии, в шаблонах неиспользуется, нужен для автообновления фильтрованного контента
$post.password - пароль записи, используется если способ доступавыбран как "оодиночный пароль"
$post.teaser - текст после анонса, если нет тега more внутри записи, то пустая строка
$post.contentpage - текст записи на текущей странице при многостраничном контенте
$post.pagescount - количество страниц текста в записи, имеет смысл если текст был разбит тегом<!--nextpage-->
$post.countpages - максимум между количеством страниц текста и страниц комментариев
$post.commentpages - количество страниц комментариев, обычно это 1
$post.lastcommenturl - адрес последней страницы, если страниц нет, то адрес записи
$post.image - url первой картинки в записи, если нет, то пустая строка
$post.thumb - url первой миниатюрыв записи, если нет, то пустая строка
$post.author - уникальный id автора, по умолчанию 0, 1 всегда у главного администратора
$post.authorname - имя автора записи, если нет автора, то значение тега $site.author
$post.authorlink - html  ссылка на автора /users.htm?id= id автора, если в профиле автора есть сайт, то будет редирект на сайт автора
$post.authorpage - html  ссылка на страницу автора, если нет страницы - то пустая строка

Последние теги относятся к странице автора, но поскольку вам может не хватить тегов для автора, то в шаблонах записи вы можете использовать свойства сателитного объекта $author.* Ознакомится с доступными тегами вы можете в описании шаблона content.author, все эти теги также доступны в шаблоне записи. Безусловно, эти теги имеют смысл только при многопользовательском режиме (включается в админке на странице настройки/безопасность).

Получился обширный список тегов, которые вы можете использовать в шаблоне записи. Некоторым из тегов записи вы можете задать свои шаблоны, а именно вот этим:

$post.date - отформатированная и переведенная дата публикации поста
$post.filelist - список файлов записи, длясписка есть свой шаблон
$post.taglinks - ссылки на метки записи
$post.catlinks - ссылки на рубрики записи
$post.more - шаблон для внутристраничной ссылки из анонса, то есть куда ссылается ссылка "Далее" из анонса
$post.rsslink - ссылка на rss комментариев к записи
$post.prevnext - ссылки на следующую и предыдущую запись
$post.templatecomments - выводит список комментариев и форму для отправки комментария. имеет много вложенных шаблонов.

Теперь можно задать детальные шаблоны для каждого из приведенных в списке тегов, в конце рассмотрим шаблон комментариев, как самый сложный. Начнем по порядку - с шаблона формата даты публикации

content.post.date = [d.m.Y]

Как видим формат простой - это параметры для php функции date, и вданном случае это d.m.Y, дата будет переведена на язык сайта. Обявим внутристраничную ссылку для ссылки "Далее..." из анонса записи:
content.post.more = [<span class="more" id="more-$post.id"></span>]

Как видим шаблон примитивный и его объявление является формальностью. Следующим тегом идет $post.taglinks, зададим шаблон для списка меток

content.post.taglinks = [
							$lang.tags: 
								$item = [ <a href="$link" title="$title" rel="tag">$icon$title</a>]
								$divider = [, ]
]

Шаблон получился не сложным, в нем присутствует строка $lang.tags - "Метки", а также два вложенных шаблона:
$ITEM - ШАБЛОН ОДНОЙ МЕТКИ
$divider - шаблон разделителя ссылок

 Все. Симметрично устроен шаблон для рубрик. Объявим его

content.post.catlinks = [
							$lang.categories: 
								$item = [ <a href="$link" title="$title" rel="category">$icon$title</a>]
								$divider = [, ]
]

Вся разница между двумя этими шаблонами в $lang - в первом случае это "Метки", а во втором - "Рубрики".Для каждой метки и рубрики в шаблоне $item доступны следующие теги:

$id - уникальный id метки или рубрики
$link - адрес, включает адрес сайта
$url - адрес без адреса сайта
$title - название (заголовок) метки или рубрики
$itemscount - количество записей в метке или рубрике
$parent - уникальный id родительской метки или рубрики, имеет смысл при вложенных метакх и рубриках
$icon - html иконка, если есть

Перед тем, как расматривать шаблон списка файлов рассмотрим два несложных шаблона - ссылка на RSS и ссылки на следующую и предыдущую запись.

content.post.rsslink = [
<span class="post-rsscomments"><a href="$post.rsscomments" title="$lang.subscribetorsscomments" >$lang.subscribetorsscomments</a></span>
]

В этом шаблоне встречаются два тега: $post.rsscomments - это адресс ссылки RSS комментариев записи, а $lang - строка "Подписаться на RSS комментариев". Все более чем просто. Также несложный шаблон ссыллок на следующую и предыдущую запись:

content.post.prevnext = [
								<div id="prevnext">
								$prev = [<p id="prev">&larr; $lang.prev <a rel="prev" href="$prevpost.link" title="$lang.permalink $prevpost.title">$prevpost.title</a></p>]
								$next = [<p id="next">$lang.next <a rel="next" href="$nextpost.link" title="$lang.permalink $nextpost.title">$nextpost.title</a> &rarr;</p>]
								</div>
]

В шаблоне есть всего два вложенных шаблона:
$prev - шаблон ссылки на предыдущую запись
$next - шаблон ссылки на следующую запись

В каждом из этих двух шаблонов доступны (и вобщем шаблоне) теги 

$prevpost - предыдущая запись
$nextpost - следующая запись

Разрешено использовать любые теги для записи, здесь же использовались уже ранее встречавшиеся свойства записи link  и title. Перейдем к более сложному и важному шаблону - шаблон списка файлов.

content.post.filelist = [
<div class="filelist-all filelist-$count" id="files-$post.id">
$files = [<div class="files-block filelist-file"><ul>
$file = [<li class="file"><a id="postfile-$post.id-$id" href="$link" data-file="$json" title="$description">$title</a></li>]
</ul></div>]
$images= [<div class="files-block filelist-image">
$image = [<span class="image"><a class="photo" id="postfile-$post.id-$id" rel="prettyPhoto[gallery-$post.id]" itemprop="image" href="$link" title="$title" data-file="$json">$preview</a></span>]
$preview = [<img class="photo" src="$preview.link" alt="$title" title="$description" />]
</div>]
$videos = [<div class="files-block filelist-video">
$video = [<span class="image"><a title="$title" rel="video" class="videofile" id="postfile-$post.id-$id" href="$link" data-file="$json">$preview</a></span>]
$fallback = [<img class="video-fallback" src="$site.files/js/litepubl/deprecated/icons/videoplayer.jpg" alt="$title" />]
</div>]
$audios = [<div class="files-block filelist-audio">
  $audio = [<audio id="postfile-$post.id-$id" src="$link" type="$mime" controls="controls"></audio>]
</div>]
$flashs = [<div class="files-block filelist-flash">
$flash = [<div class="flash-holder">
<object type="application/x-shockwave-flash" data="$link" width="$width" height="$height" id="flashplayer-$id" name="flashplayer-$id">
<param name="movie" value="$link" />
<param name="allowfullscreen" value="true" />
<param name="allowscriptaccess" value="always" />
<param name="menu" value="false" />
<param name="wmode" value="transparent" />
<param name="FlashVars" value="autostart=true" />
</object>
</div>]
</div>]

</div>]

Мы видим объявление в списке файлов шаблоны для разных типов. Несложно догадатся, какой шаблон отвечает за какой тип файлов

$file - отсутствует тип файла, скорее всего это бинарник
$image - картинка, по умолчанию к картинкам создаются миниатюры. Этот шаблон для картинок сразу организует их в галерею
$preview - шаблон для миниатюр, они используются в галерее
$audio - шаблон для аудиофайлов, этот шаблон сразу подключает плеер
$video - шаблон для видеороликов. Видеоплеер будет запущен в открывшейся галерее после клика по миниатюре видеоролика. Если у видео отсутствует миниатюра, то будет использована общая миниатюра для видео
$flash - шаблон для флеш. Флеш ролик будет встроен прямо в страницу

LitePublisher генерирует список файлов на основе этих шаблонов, файлы сортируются по типам. Внутри шаблона длялюбого типа файла доступны свойства файла, а именно:
$id - уникальный id файла (число)
$media - тип файла, строка имеет одно из следующих значений: 'bin','image','icon','audio','video','flash', 'document','executable','text','archive'
$parent - уникальный id родительского файла, в шаблонах = 0, кроме шаблона для миниатюр - $preview
$preview - уникальный id миниатюры, если миниатюры нет, то равен 0. Имеет смысл только для картинок
$icon - уникальный id иконки для этого типа файлов. В настоящее время не используется и равно 0.
$author - уникальный id автора файла. Имеет смысл при многопользовательском режиме.
$idperm - уникальный id ограниченного доступа к файлу. В шаблонах не используется
$size - размер в байтах файла
$posted - дата добавления файла
$mime - mime тип файла, строка, не всегда возможно коректное значение
$filename - имя файла, включая папку относительно общей папки файлов. Полный адрес к файлу получается $site.files/files/$filename
$link - полный адрес к файлу, включает адрес сайта
$title - название файла, если не было задано, то равно имени файла
$description - описание файла, пустая строка, если не задано 
$keywords - ключевые слова для файла, пустая строка, если не задано
$hash - строка равна закодированному хешу md5 файла (22 букв и цифр), используется для фильтрации копий файлов, в шаблонах не используется
$height - высота картинки, для других типов файлов = 0
$width - ширина картинки, для других типов файлов = 0
$index - номер файла в списке начиная с нуля
$typeindex - номер файла в подсписке файлов по типам, начиная с нуля
$json - строка, полученная json кодированием всех свойств файла (выше их перечислили) за исключением 3 свойств: $title, $description, $keywords. Эти свойства исключены из за дублирования и их размера. в этой строке все символы " заменены на &quot;  - сделано это для использования $json в атрибутах тегов, здесь в шаблоне это data-file="$json"

Кроме свойст файла доступны еще 2 тега:
$count - общее количество файлов в посте
$subcount - количество файлов одного типа в каждом из шаблонов. Если например кроме картинок нет других файлов, то $subcount совпадает с $count, справидливо для любых типов файлов.

Вы можете использовать любую комбинацию этих значений в шаблоне файлов. Как видно из верстки, сам список и файлы по типам разделены блочными элементами с переносом строк (смотрите файл js/litepublisher/filelist.css). Если в посте много картинок, то такая верстка работает отлично, разграничивая блок с миниатюрами и текстом поста. В случае одной - двух фоток в посте выглядит уже не так привлекательно из за пустого места справа от миниатюр. Чтобы разрулить оба варианта в движок включен скрипт js/litepublisher/filelist.js, который ориентируясь на эту верстку удаляет div'ы вокруг миниатюр и добавляет класс files-block к первому div или p после миниатюр. Тогда текст поста получается  сразу справа от миниатюр. Учитывайте это в своей разработке. Скрипт можно всегда удалить или добавить в сборщике js (админка вид/сборщик js).

По умолчанию в движок включена галерея prettyPhoto, клон известной галереи lightbox для jquery, подробную информацию о настройках и возможностях галереи вы можете узнать на официальном сайте галереи (http://www.no-margin-for-errors.com). Вы, безусловно, можете использовать любую другую галерею, но надо заметить, что эта галерея обладает своим апи для расширений, может организовывать не только картинки, но и флэш, html, видео, видео ютьюба. В этом шаблоне картинки организованы по галереям для каждого поста, то есть в одном посте все его картинки будут в одной галерее, в следующем посте будет следующая галерея. За это отвечает шаблон для prettyPhoto rel="prettyPhoto[gallery-$post.id]" В сборщик js файлов по умолчанию включен следующий javascript (вы всегда можете это отредактировать в админке) для инициализации галереи:

  $(document).ready(function() {
    $("a[rel^=\'prettyPhoto\']").prettyPhoto({
      social_tools: false
    });
  });

Файл стилей галереи подключается в сборщике css, который вы можете найти в админке в подменю "Вид". Также сборщик стилей подключает файл /js/litepublisher/css/filelist.min.css, в котором находятся стили для списка файлов. Таким образом, используется один шаблон и стили к нему в других темах и нет необходимости копировать стили для списка файлов для своей темы.

Обратите внимание - в шаблоне ссылки картинки стоит class="photo" Сам же класс photo отсутствует в стилях и класс был добавлен для поддержки микроформатов таких, как hproduct, hlisting. Пожалуйста оставьте класс photo в своих шаблонах, потому что это поможет поддержке микроформатов.

Кроме скрипта галереи в сборщике javascript включены скрипты аудио и видео плееров. Рассмотрим их подробнее.  Используется библиотека MediaElement.js (http://mediaelementjs.com/), которая поддерживает html5 и флеш плееры одновременно. Скрипт litepublisher анализирует список файлов и для аудио файлов сразу встраивает аудиоплеер. Видео обслуживается по другому - видеоплеер будет открываться внутри галереи по клику по миниатюре. Таким образом открытие картинок и видео происходит симметричным образом, экономя место в основном контенте страницы. Размеры видео плеера задаются в админке настройки/файлы. Исходный текст jquery скрипта можете найти в файле /js/litepublisher/players.js, который подключается сборщиком javascript движка (в админке можете отредактировать список файлов на странице Вид/Сборщик JS). Могут возникнуть вопросы про миниатюры для видео - по умолчанию, для видео у которого нет миниатюры,  используется  файл js/litepublisher/icons/videoplayer.jpg, но вы всегда можете поменять миниатюры у файлов в админке. Движок не имеет средств извлечения миниатюр из видео, так как задача анализа видео, выходит  далеко за рамки php скриптов и требует наличия на хостинге инструментов подобных ffmpeg, который не предоставляется на шаред хостинге.

Для многих список файлов в теме является очень важным вопросом, поэтому за дополнительной информацией обращайтесь в тикет систему по адресу:
http://litepublisher.ru/

Переходим к шаблону списка комментариев  content.post.templatecomments, который включает в себя множество шаблонов, а именно:

$closed - шаблон сообщения о закрытом комментировании
$form - форма отправки комментария
$confirmform - форма подтверждения комментария
$comments - шаблон списка комментариев
$pingbacks - список пингбеков

Будем разбирать каждый из этих шаблонов по нарастанию сложности. Самый простой шаблон - сообщение закрыто:

content.post.templatecomments.closed = [<p class="nocomments">$lang.closed</p>]

Внутри шаблона встречается тег $lang.closed - строка "Комментирование закрыто". Далее посмотрим на шаблон формы комментирования - в зависимости от настроек записи будет выдаваться сообщение о закрытом комментировании либо форма отправки. Объявим форму комментирования для зарегистрированных посетителей и гостей:

content.post.templatecomments.regform = [
								<div id="before-commentform">$mesg</div>
								<p id="respond">$lang.leavereply</p>
								<form action="$site.url/send-comment.php" method="post" id="commentform">
									<p><textarea name="content" id="comment" rows="10" cols="60%"></textarea></p>
<div style="text-align: center;">
<input type="hidden" name="postid" value="$postid" />
<input type="hidden" name="antispam" value="$antispam" />
<div style="margin: auto;"><button type="submit" name="submitcomment" class="button" id="id-submitcomment"><span>$lang.send</span></button></div></div>
								</form>
]

Простая форма включает в себя только один редактор текста. Этим можно было бы и ограничется, но нам нужно предупредить зарегистрированного пользователя от чьего имени он оставляет комментарий, для анонимных гостей выдать другое сообщение. Также желательно бы разместить дополнительную информацию о возможности регистрации, в том числе и через социальные сети. Просто говоря - нужно место, где это поместить. Для этого предусмотрен div с тегом $mesg - текст подсказки, его можно всегда поправить в админке на странице Настройки/Комментарии.

 Также в этом шаблоне следует указать селекторы jquery отличные от темы по умолчанию. О том, что и как  следует ли делать это в принципе пойдет разговор после обяснений всех шаблонов комментариев, так как рекомендации по вставке кода будут касаться всех объявленных шаблонов. Вставляемый код будет простым javascript.

В движке предусмотрена возможность оставлять комментарии без регистрации, но с указанием email и имени комментатора. Вот эта форма:

content.post.templatecomments.form = [
<div id="before-commentform">$mesg</div>
										<p id="respond">$lang.leavereply</p>
								<form action="$site.url/send-comment.php" method="post" id="commentform">
									<p><input type="text" name="name" id="name" value="$name" size="22" />
									<label for="name">$lang.name</label></p>

									<p><input type="text" name="email" id="email" value="$email" size="22" />
									<label for="email">$lang.email</label></p>

									<p><input type="text" name="url" id="url" value="$url" size="22" />
									<label for="url">$lang.url</label></p>

									<p><input type="checkbox" name="subscribe" id="subscribe" $subscribe size="22" />
									<label for="subscribe">$lang.subscribe</label></p>

									<p><textarea name="content" id="comment" rows="10" cols="60%"></textarea></p>
<div style="text-align: center;">
<input type="hidden" name="postid" value="$postid" />
<input type="hidden" name="antispam" value="$antispam" />
<div style="margin: auto;"><button type="submit" name="submitcomment" class="button" id="id-submitcomment"><span>$lang.send</span></button></div></div>
								</form>
]

Шаблон не смотря на свой объем является простым, так как не включает в себя вложенных шаблонов. В шаблоне формы использовались следующие теги:

$name - имя комментатора
$email - E-Mail комментатора
$url - адрес сайта комментатора
$subscribe - подписка по E-Mail, пустая строка либо checked="checked"
$content - текст комментария
$postid - уникальный id записи к которой отправляется комментарий
$antispam - строка созданная движком для защиты от спама

Если комментатор первый раз оставляет комментарий, то $name, $email, $url являются пустыми строками, а если комментатор уже отправлял свой комментарий, то они заполняются соответствующими значениями. Особняком стоит значение $subscribe - подписка на E-Mail новых комментариев: для первый раз комментирующего это значение выставляется в зависимости от настроек сайта, для повторного комментатора в том значении, в котором он последний раз комментировал. Также обратите ваше внимание на вставку javascript, это файл $site.files$template.jsmerger_comments - он обрабатывает нажатия кнопок цитирования в списке комментариев. Поскольку эти кнопки цитирования имеют смысл только при открытом комментировании, то и подключения скрипта для этих кнопок естественно расположить в форме комментирования. G\По умолчанию сборщик js файлов содержит для комментариев файл из дистрибутива /js/litepublisher/comments.min.js и секкцию comments из языкового файла. Языковой файл нужен для текста цитирования.

Следующей после отправки комментария находится форма подтверждения оного. Зададим шаблон для формы подтверждения:

content.post.templatecomments.confirmform = [
								<h4>$lang.checkspam</h4>
								<form name="preform" method="post" action="">
								  <p><input type="submit" name="submit1" value="$lang.robot"/></p>
								</form>

								<form name="form" method="post" action="">
							  <p><input type="submit" name="submit2" value="$lang.human"/>
								<input type="hidden" name="confirmid" value="$confirmid" />
</p>
								</form>
]

Как видим этот шаблон состоит из двух форм - ложной формы для роботов и форма для людей. В форме для людей находится  один шаблон:
$confirmid - строка с набором цифр и букв для подтверждения комментария. Для каждого комментария генерируется случайно своя собственная строка, эту комбинацию невозможно угадать и она становится известной только после заполнения формы отправки комментария. Такая простая защита отсеивает спам и позволяет людям спокойно отправлять комментарии.

Перейдем к главному - список комментариев и сам шаблон комментария. Есть два списка комментариев: одобренных и задержанных. Главным, безусловно, является список одобренных, а второстепенным является список задержанных комментариев. Шаблон списка включает в себя следующие шаблоны:
$count - шаблон количества комментариев на запись
$comment - шаблон комментария

Начнем объявлять шаблоны с шаблона количества:
content.post.templatecomments.comments.count = [
<p id="comments">$count $lang.topost &#8220;$post.title&#8221;</p>
]

В шаблоне количества комментариев нам доступны следующие теги:

$post.* - все свойства записи $post, здесь использовали title -заголовок записи
$count - собствено число комментариев, уже отформатированое для языка (0 = нет комментариев, 1 = 1 комментарий, и так далее)
$lang.topost - строка "на запись"

А вот и сам список комментариев:
content.post.templatecomments.comments = [
  <ol class="commentlist" id="commentlist" start="$from">
$comment
										</ol>
]

Как видим шаблон простой и в нем использовались 2 шаблона:
$from - число откуда начинается отсчет комментариев, обычно это 1, но при большом количестве комментариев и разбивки на страницы это число равно например 101
$comment - шаблон комментария

Обратите внимание на строку:
<script type="text/javascript">ltoptions.theme.commentlist = "#commentlist";</script>

Она предназначена для связи с javascript, которые смогли бы найти список комментариев. Указано значение "#commentlist" - id списка, которое также является селектором для jquery.

Объявим шаблон для списка задержанных - он является почти полной копией списка одобренных:

content.post.templatecomments.holdcomments = [
<p class="hold"><em>$lang.hold</em></p>
  <a id="holdcomments"></a>
  <ol class="commentlist" id="holdcommentlist" start="1">
$comment
										</ol>]

Следует обратить внимание на  атрибут start тега ol, который не является валидным для xhtml, но является валидным в html5 и html4. Поскольку эта тема имеет doctype xhtml, то шаблон списка комментариев не пройдет валидацию. LitePublisher предоставляет способ обойти это ограничение. Следует отказаться от тега ol в пользу тега ul без атрибута start, а в  стилях прописать list-style: none; и в шаблоне комментария использовать $index для нумерации комментариев. Передекларируем список комментариев (формат темы это позволяет - последнее объявление шаблона будет использовано в конечном итоге)

content.post.templatecomments.comments = [
  <ul class="commentlist" id="commentlist" style="list-style: none;">
$comment
										</ul>]

Объявим шаблон комментария:

content.post.templatecomments.comments.comment = [
 <li $class1=[class="alt"] $class2=[] id="comment-$comment.id">
 $index .
  <div class="commentmetadata"><a href="#comment-$comment.id" title=""><span class="date">$comment.date = [d.m.Y]</span> $lang.attime <span class="time">$comment.time</span></a></div>
  <span class="vcard author"><cite>$comment.authorlink</cite> $lang.says:  </span>
  <div class="moderationbuttons" data-idcomment="$comment.id" data-idauthor="$comment.author"></div>
  <div class="commentcontent" id="commentcontent-$comment.id" >$comment.content</div>
  $quotebuttons = [
  <div class="replyquotebuttons">
   <button type="button" class="button replycomment" data-idcomment="$comment.id" data-authorname="$comment.name"><span>$lang.reply</span></button>
   <button type="button" class="button quotecomment" data-idcomment="$comment.id" data-authorname="$comment.name"><span>$lang.quote</span></button>
  </div>]
 </li>]

В шаблоне комментария мы видим несколько вложенных шаблонов и активное использование тегов $comment.* Рассмотрим вложенные шаблоны:
$class1 - html класс нечетных комментариев
$class2 - html класс четных комментариев (в данном примере класс отсутствует)
$index - целое число, индекс комментария, используется если, к примеру, был обявлен ранее шаблон списка ul
$indexplus- тоже самое , что и $index но на 1 больше, поэтому нумерация начнется с 1
$comment.date - шаблон даты комментария, не обязательный шаблон
$quotebuttons - вложенный шаблон кнопок цитирования, имеют смысл при открытом комментировании. Если комментирование отключено, то эти кнопки не показываются

Как видим вложенных шаблонов немного, зато много свойств у $comment, перечислим их

$comment.id - уникальный id (число) комментария
$comment.post - уникальный id (число) записи для которой комментарий
$comment.author - уникальный id (число) автора комментария
$comment.parent - уникальный id (число) родительского комментария, в настоящее время не используется и = 0
$comment.posted - дата добавления в формате timestamp (целое число)
$comment.status - статус комментария, только в бд версии, возможные значения: 'approved','hold','spam','deleted'
$comment.content - отфильтрованный текст комментария
$comment.authorlink - html ссылка на автора комментария, может быть только имя комментатора в зависимости от настроек сайта
$comment.date - отформатированная строка дата отправления комментария, для этого тега можно задать свой шаблон. Если шаблони не задан, то используется формат по умолчанию
$comment.time - время отправления комментария, используется шаблон даты "H:i" (час:минуты)
$comment.localstatus - состояние комментария, переведенная на язык строка, например "одобрен", "задержан"
$comment.website - адрес сайта комментатора
$comment.url - адрес записи с (#) внутристраничной ссылкой на комментарий
$comment.posttitle - заголовок записи для которой комментарий
$comment.rawcontent - неотфильтрованный текст комментатора
$comment.IP - IP адрес комментатора
$comment.md5email - md5 хеш E-Mail комментатора
$comment.gravatar - html картинка аватара комментатора с сайта http://www.gravatar.com/

Понятно, что не все перечисленные теги используются в шаблоне комментария, а только их часть. Следует остановиться на шаблоне даты $comment.date - вы можете просто вставить этот тег в шаблон, а если хотите задать свой собственный шаблон даты, то вам следует это сделать привычным для формата темы способом $comment.date = [ваш формат даты] Формат даты - это формат даты для функции PHP date, в данном примере это "d.m.Y"

Обратим внимание на HTML разметку, в частности - шаблон hCard, в нашем случае это <span class="vcard author"> Особого значения это не имеет, но вероятно поможет поисковикам более благосклонно относится к вашему сайту потому, что поисковики обрабатывают микроформаты hCard.

Следующий момент - пустой тег div с классом moderationbuttons. Он предназначен для кнопок модерирования, которые будут вставлены скриптом (js/litepublisher/moderate.js) для  залогиненных поситителей в зависимости от прав. Для администратора и модератора будут добавлены все кнопки (задержать, одобрить, удалить, редактировать) для каждого комментария. Для рядовых комментаторов могут быть показаны кнопки редактировать и/или удалить в зависимости от настроек (в админке настройки/комментарии галочки прав).  Разберем шаблон
<div class="moderationbuttons" data-idcomment="$comment.id" data-idauthor="$comment.author"></div>

В атрибутах data* передана информация о текущем комментарии, а именно:
$comment.id - уникальный id комментария
$comment.author - уникальный id автора

Вы должны обязательно вставить эти атрибуты для передачи данных скрипту. Чтобы HTML не ругался на вашу тему, она должна поддерживать RDFa  (указывается в DOCTYPE) или быть HTML 5 версии. Чтобы вместо ряда кнопок первоначально показывалась одна кнопка "E", следует добавить класс hidden к  moderationbuttons. Тогда будет видна только одна кнопка E, по клику заменяется на кнопки модерирования.

Чтобы скрипт (js/litepublisher/moderate.js) смог коректно отработать, ему нужна дополнительная информация о структуре HTML списка комментария, необходимо в скрипт передать jquery селекторы. Скрипт следует вставлять в шаблон content.post.templatecomments.regform задекларированный ранее. Здесь, в теме по умолчанию отсутствует  скрипт потому, что  (js/litepublisher/moderate.js) имеет значения по умолчанию равные теме по умолчанию. Продемонстрируем полный текст возможного скрипта:

<script type="text/javascript"> ltoptions.theme.comments = $.extend(true, ltoptions.theme.comments, {
        // список комментариев в виде селектора (включает символ # для id списка)
        comments: "#commentlist",
        // селектор списка задержанных комментариев, включая символ# для id
        hold: "#holdcommentlist",
        // селектор одиночного комментария, полный получается если прибавить id, пример#comment-357
        comment: "#comment-",
        // селектор текста комментария, к нему прибавляется id, пример #commentcontent-357
        content: "#commentcontent-",
        // селектор владельца, куда будут вставлены кнопки модерирования, в теме по умолчанию это <div class="moderationbuttons" ...
        buttons:".moderationbuttons",
        // шаблон кнопки модерирования, %%title%% будет заменен на название кнопки (одобрить, задержать, редактировать, удалить)
        button: '<button type="button" class="button"><span>%%title%%</span></button>',
        //класс кнопки "Ответить"
        replyclass: "replycomment",
        //клас кнопки "Цитировать"
quoteclass : "quotecomment",
        // селектор формы комментариев, здесь id тега form
        form: "#commentform",
        // селектор редактора, то есть textarea формы
        editor: "#comment"
      });
</script>
      
Естественно, что в вашей теме не потребуется указывать все эти селекторы, если они совпадают с темой по умолчанию. Например, если у вас будет другой только шаблон кнопки модерирования, то достаточно указать только ее одну:

<script type="text/javascript"> ltoptions.theme.comments = $.extend(true, ltoptions.theme.comments, {
        button: '<a href=#">%%title%%</a>'
      });
</script>

Напомним, что этот скрипт следует добавлять к шаблону content.post.templatecomments.regform задекларированный ранее.

С комментариями практически все - остались только пингбеки. Вот шаблон пингбеков:

content.post.templatecomments.pingbacks = [
 <p id="pingbacks">$lang.pingbacks</p>
 <ol class="commentlist" start="1">
  $pingback = [
  <li class="alt" id="pingback-$pingback.id">
   <cite><a href="$pingback.url">$pingback.title</a></cite>
  </li>
 ]
 </ol>
]

Вшаблоне пингбеков мы видим вложенный шаблон пингбека. На самом деле получается несколько урезанный шаблон комментариев. Внутри шаблона пингбека используется теги $pingback.*, перечислим свойства пингбека:

$pingback.id - уникальный id (число)
$pingback.url - адрес пингбека, то есть адрес сайт с которого стоит ссылка на запись
$pingback.title - заголовок страницы, на которой стоит ссылка на запись
$pingback.post - уникальный id (число) где находится пингбек
$pingback.posted - дата в формате sql  или timestamp (зависит от версии движка)
$pingback.ip - IP адрес откуда пришел пингбек

С комментариями все. Осталось только рассказать в какой последовательности генерируется контент. Вначале идет список одобренных комментариев, потом задержанные (если есть), потом пингбеки, и в конце форма добавления комментария.

Таким образом мы закончили описывать шаблон полной записи. Перейдем к описанию шаблонов анонсов. На верхнем уровне есть 3 шаблона анонсов:
content.excerpts - шаблон списка анонсов, как правило пустая строка
content.excerpts.excerpt - шаблон анонса записи, включает в себя вложенные шаблоны
content.excerpts.lite - шаблон анонсов для lite (облегченного) режима

Немного о шаблоне content.excerpts - это html, который может обрамлять анонсы, как правило отсутствует. Например вы можете задать такой шаблон до и после объявления вложенного тега $excerpt (он же content.excerpts.excerpt):

content.excerpts = [
 $excerpt = [
		<div class="post" id="post-$post.id">
			<h2><a href="$post.link" rel="bookmark" title="$lang.permalink $post.title">$post.iconlink$post.title</a></h2>
				<span class="post-date">$post.excerptdate = [d.m.Y]</span>
				<span class="post-tags">$post.taglinks</span>
			<div class="post-content">
				$post.excerptfilelist
$post.excerptcontent
				$post.morelink = [<a href="$post.link#more-$post.id" class="more-link">$post.moretitle</a>]
			</div>
			<div class="post-info">
				<span class="post-comments">$post.commentslink</span>
				<span class="post-cat">$post.catlinks</span>	
			</div>
		</div>
]
]

Как видим, мы использовали ранее известные теги $post.* по шаблону полной записи. То есть тег $post.catlinks будет использовать шаблон полной записи для рубрик. Если вы хотите, чтобы шаблоны в анонсе отличались от шаблонов полной записи, то вы это можете сделать. Например вместо $post.catlinks поставить тег $post.excerptcatlinks. Также вы можете безопасно вставлять теги для анонсов - если вы не оббявите соответствующие шаблоны для анонсов, то будут использованы шаблоны для полной записи. Перечислим шаблоны для анонса:

content.excerpts.excerpt.date - $post.excerptdate, шаблон формата даты для анонса в формате для PHP функции date()
content.excerpts.excerpt.catlinks - $post.excerptcatlinks, шаблон для рубрик в анонсе, имеет точно такой же формат как и для шаблона рубрик в полной записи
content.excerpts.excerpt.taglinks - $post.excerpttaglinks, шаблон для меток в анонсе, имеет точно такой же формат как и для шаблона меток в полной записи
content.excerpts.excerpt.filelist - $post.excerptfilelist, шаблон для списка файлов в анонсе, имеет точно такой же формат как и для шаблона списка файлов в полной записи
content.excerpts.excerpt.firstimage - $post.firstimage, шаблон для первой картинки в записи. Используется для минимизации анонса, когда надо показать всего лишь одну картинку

Из специфических только для анонса можно выделить шаблон $post.morelink (он же content.excerpts.excerpt.morelink) - это шаблон ссылки "Далее" в анонсе. Этот тег можно вставлять только для объявления шаблона, без шаблона его не следует вообще употреблять. В шаблоне анонса записи ммы обявили вложенный шаблон для тега $post.morelink. Если у записи нет анонса, то этот тег возвращает пустую строку. Этот тег автоматически вставляется внутри $post.excerptcontent и поэтому его не следует просто так ставить - тогда скорее всего появится две ссылки "Далее".

Следует наверно продемонстрировать, как изменить один из шаблонов, например картинки в списке файлов анонса (убирите // в начале строки чтобы раскомментировать):
//content.excerpts.excerpt.filelist.image = [<li><a rel="prettyPhoto[gallery-$post.id]" href="$link" title="$title">$preview</a></li>]

На самом деле мы задали абсолютно такой же шаблон как и восновном списке, но вы можете изменить шаблон по своему вкусу. Зададим шабон для первой картинки в записи:

content.excerpts.excerpt.firstimage = [
<div class="anpost-image">
<a class="fn url photo" href="$post.link" title="$post.title" data-image="$link"><img src="$preview.link" alt="$post.title" /></a>
</div>]

Если взаписи есть картинки, то тег $post.firstimage с помощью этого шаблона выведет первую картинку. Удобно, когда требуется вывести в анонсе записи всего одну миниатюру.

Следующим шаблоном будет шаблон для lite режима. Lite режим - это использование шаблона lite для анонсов и разбивка на страницы по 1000 записей на страницу. Предназначен такой режим для предовращения дублирования контента, которое происходит при классических анонсах, что может негативно влиять на ранжирование поисковыми машинами.

content.excerpts.lite = [
			<h1>$lang.posts</h1>
			<ul>
				$excerpt = [<li><a href="$post.link" title="$lang.permalink $post.title">$post.title</a></li>]
			</ul>
]

Как видим шаблон простой и включает в себя один вложенный шаблон $excerpt - элемент списка. Внутри $excerpt доступны все теги $post.*

В секции content нам осталось описать еще два шаблона - navi и admin. Шаблон navi предназначен для постраничной навигации, зададим его:

content.navi = [
	<div class="navigation" data-page="$page" data-count="$count" data-perpage="$perpage">
			$prev = []
			$next = []
			$link = [<a href="$link">$page</a>]
			$current = [$page]
			$divider = [|]
 </div>
]

Как видно, в шаблоне navi описаны 4 вложенных шаблона, а именно

$prev - шаблон для ссылки на предыдущую страницу. Устарел и не используется.
$next - шаблон ссылки на следующую страницу. Устарел и не используется как и шаблон $prev. Шаблоны оставлены для обратной совместимости.
$link - шаблон одной ссылки
$current - ссылка на текущую страницу, в данном случае ссылка отсутствует - только номер
$divider - разделитель между ссылками

В шаблоне $link доступны следующие теги для ее формирования:
$link - полный адрес страницы, включая адрес сайта
$url - адрес страницы без адреса сайта
$page - номер страницы, цифра

Шаблоны $prev и $next используются редко, так как могут выводит всего одну/две ссылки ранее/позже, что при большом количестве страниц очень неэфективно. В настоящий момент выводится целая полоска со ссылками на номера страниц. Поэтому вы можете не описывать шаблоны $prevи $next, они оставлены больше по историчиским причинам.

Остался последний шаблон в секции content - admin, вот его сейчас и опишим:

content.admin = [
$tableclass = [classictable]

$editor = [<p><label for="editor-$name">$lang.$name:</label><br />
<textarea name="$name" id="editor-$name" cols="57%" rows="10">$value</textarea></p>]

$text = [<p><input type="text" name="$name" id="text-$name" value="$value" size="22" />
<label for="text-$name">$lang.$name</label></p>]

$password = [<p><input type="password" name="$name" id="password-$name" value="$value" size="22" />
<label for="password-$name">$lang.$name</label></p>]

$upload = [<div><label for="file-$name">$lang.$name</label>
<INPUT type="file" name="$name" id="file-$name" /></div>]

$checkbox= [<p><input type="checkbox" name="$name" id="checkbox-$name" $value />
<label for="checkbox-$name">$lang.$name</label></p>]

$combo = [<p><label for="combo-$name">$lang.$name:</label>
<select name="$name" id="combo-$name">$value</select></p>]

$radioitem = [<p><label><input type="radio" name="$name" id="radio_$name_$index" value="$index" $checked />$value</label></p>]

$radio = [<div><h4>$lang.$name:</h4>$value</div>]

$hidden = [<input type="hidden" name="$name" id="hidden-$name" value="$value" />]
$button =   [<button type="submit" name="$name" id="submitbutton-$name" class="button"><span>$lang.$name</span></button>]
$submit =   [        <div class="text-center"><div class="margin-auto"><button type="submit" name="$name" id="submitbutton-$name" class="button"><span>$lang.$name</span></button></div></div>]

$form = [<h3>$formtitle</h3>
<form action="" method="post" role="form">
$items
[submit=update]
</form>]

]

Шаблон admin предназначен длягенерации форм в админке. Перечислим их

$text - шаблон однострочного редактора
$editor - шаблон многострочного редактора
$checkbox - шаблон чекбокса
$combo - шаблон комбобокса
$hidden - поле hidden, для упрощения генерации
$button - шаблон кнопки отправки формы
$submit - шаблон кнопки отправки формы, выровненный по центру
$form - шаблон формы
$tableclass - класс таблиц с рамочками, в фреймворке bootstrap это будет [table table-bordered] Добавлен в версии 5.73

Все - мы закончили с тегом $template.content и его шаблонами, перейдем к сайдбарам. За сайдбар отвечает тег $template.sidebar - вы можете в шаблоне полной страницы проставить несколько тегов $template.sidebar и таким образом мы получим несколько сайдбаров. Как же адресовать конкретный шаблон сайдбара? Нумерация сайдбаров идет сверху вниз по мере нахождения в шаблоне полной страницы тегов $template.sidebar. Таким образом первый встретившийся тег $template.sidebar будет означать объявление 0-го сайдбара. В движке есть теги вида $template.sidebar0, $template.sidebar1, $template.sidebar2, которые однозначно задают номер сайдбара. $template.sidebar является синонимом $template.sidebar0. В шаблоне всей страницы вы можете использовать только тег $template.sidebar,  без указания индексов, но в обявлении вы обязаны задать номер декларируемого сайдбара.

В каждом сайдбаре обязан быть шаблон $widget - виджет. Если не будет объявлен один из стандартных шаблонов виджетов, то будет использоваться шаблон по умолчанию для виджета $widget, поэтому его наличие является обязательным. Вы можете не задавать другие шаблоны, но шаблон $widget вы обязаны задать. Более того, декларация шаблона widget автоматически перезаписывает все остальные шаблоны в этом сайдбаре - обратите на это внимание. Поэтому следует всегда первым декларировать шаблон по умолчанию widget, а потом все остальные виджеты. Есть два исключения, которые шаблон widget не перезаписывает, если они уже объявлены или унаследованы:
1. sidebar.posts.item - шаблон элемента списка для свежих записей
2. sidebar.comments.item - шаблон элемента списка свежих комментариев.

Это потому, что эти два шаблона используют сильно отличающиеся теги от стандартных виджетов, как например $post и $comment, которые не доступны в любом другом виджете.

Объявим первый сайдбар, а внутри него шаблон виджета по умолчанию:

$template.sidebar = [
 $widget = [
  <div class="widget">
    <div class="rubric">$title</div>
    $items = [
    <ul class="linkcat">
      $item = [<li><a href="$link" title="$title">$icon$text</a>
$subcount = [<strong>($itemscount)</strong>]
$subitems = [<ul>$item</ul>]</li>]
    </ul>
    ]
  </div>
 ]
]

В объявлении виджета мы встречаем несколько вложенных объявлений, эти объявления для каждого типа виджетов являются практически стандартными. Перечислим их:

$title - название виджета
$items - шаблон списка
$item - шаблон элемента списка
$subcount - шаблон количества, например записей в рубрике
$subitems - шаблон вложенного списка

Видно, что все три шаблона вложены друг в друга. Если виджет в настройках является аяксовым, то используется только верхний шаблон. Для генерации контента виджета используются как раз шаблоны $items	, $item, $subitems. 

Обратим внимание на теги внутри шаблона $item:

$link - полный адрес ссылки
$title - описание, текст для атрибута title
$rel - текст для адрибута rel
$icon - не обязательный html иконки, если есть
$text - текст ссылки
$subcount html количества, например записей в рубрике
$itemscount - цифра количества , например количество записей в рубрике
$subitems - html вложенного списка, может быть другой текст

Как правило значения $title и $text совпадают, но могут и отличаться. Для генерации вложенного списка $subitms в для шаблона списка используется шаблон $item. $subitems является аналогом тега $items.

В шаблоне сайдбара можно задавать шаблоны стандартных виджетов. Перечислим их:

$widget - шаблон виджета по умолчанию
$submenu - подменю
$categories - рубрики
$tags - метки
$archives - архив
$links - ссылки
$posts - свежие записи
$comments - свежие комментарии
$friends - мои друзя
$meta - мета

Начнем задавать шаблоны для каждого из стандартных виджетов, в том же порядке и начнем с подменю:

sidebar.submenu = [
				<div class="widget">
			      <div class="rubric">$title</div>
$items = [
			      <ul class="list-page">
$item = [
          <li><a href="$link" title="$title">$icon$text</a>$subitems</li>
]
			      </ul>
]
				</div>
]

Мы видим, что шаблон виджета подменю почти ни чем не отличается от виджета по умолчанию. Также обстоят дела и с остальными шаблонами виджетов. вот шаблон виджета рубрик:

sidebar.categories = [
<div class="widget">
<div class="rubric">$title</div>
$items = [
 <ul class="list-cat" id="widgetcategories-$parent">
 $item = [
  <li><a href="$link" title="$title">$icon$text</a>$subcount$subitems</li>
 ]
</ul>
]
</div>
]

Мы видим, что шаблон рубрик опять почти полностью повторяет шаблон по умолчанию, а единственное отличие - это шаблон $items.  Формат темы позволяет не повторять одинаковые шаблоны и для виджетов указать только отличающийся шаблон (при обязательном наличии полноготшаблона по умолчанию). Тогда можно было бы свести шаблон рубрик к объявлению sidebar.categories.items = [<ul class="list-cat" id="widgetcategories">$item</ul>]. Следовательно для нижеследующих шаблонов будет достаточно объявить только отличающиеся подшаблоны. Вот шаблон архива:
sidebar.archives.items = [<ul class="list-archives" id="widgetarchives">$item</ul>]

Шаблон для свежих записей, в котором доступны теги $post.* :
sidebar.posts.item = [<li><a href="$post.link" rel="bookmark" title="$lang.permalink $post.title">$post.title</a></li>]
Шаблон для свежих комментариев:
sidebar.comments.item = [<li><a href=" $link#comment-$id" title="$name $onrecent $title">$name $onrecent $title</a>: $content...</li>]

Для шаблона свежих коменнтариев необходимы пояснения к использованным тегам. В шаблоне доступны следующие теги:
$id - уникальный id (число) комментария
$author - уникальный id (число) комментатора
$parent - уникальный id (число) родительского комментария, равно 0
$content - отфильтрованный текст комментария полностью
$text - краткая цитата из текста комментария, максимум 120 символов (для текста на русском в utf8 в два раза меньше)
$name - имя комментатора
$email - E-Mail комментатора
$url - адрес сайта комментатора
$post - уникальный id записи, где комментарий
$title - заголовок записи, где комментарий
$link - адрес записи, включая адрес сайта
$posturl - адрес записи, без адреса сайта
$onrecent - переведенная на установленный язык фраза "комментарий на"

Следующий шаблон - это мета, в котором собраны разные ссылки, например на RSS записей икомментариев и другие полезные ссылки.
sidebar.meta.item = [<li><a $class href="$link" title="$title">$icon$text</a>$subitems</li>]

В шаблон$item здесь добавлен тег $class - это html класс ссылки.  Чтобы задать html класс сылки в виджете мета есть дополнительный шаблон $classes, которого больше ни у кого нет. Зададим шаблон для классов:
sidebar.meta.classes = [rss=rss,comments=rss-comments,foaf=foaf]

Этот шаблон не является html шаблоном, как другие. В нем находятся имена классов в формате тип_ссылки=название_html_класса разделенными запятыми. Если класс не задан, то в сгенерированном html виджета не будет класса у ссылки. Известны следующие типы ссылок:

rss - ссылка на RSS записей
comments - ссылка на RSS комментариев
media - ссылка на RSS файлов
foaf - xml документ FOAF
profile - ссылка на профиль
sitemap- ссылка на карту сайта

Мы закончили с шаблоннами первого сайдбара - все недостающие шаблоны стандартных виджетов будут взяты из шаблона виджета по умолчанию. Добавим второй сайдбар:

$template.sidebar1 = [
  $widget = [
  <li>
    <div class="rubric">$title</div>
    $items = [
    <ul>
       $item = [<li><a href="$link" title="$title">$icon$text</a>
$subcount = [<strong>($itemscount)</strong>]
$subitems = [<ul>$item</ul>]
</li>]
    </ul>
    ]
  </li>
]
]

После чего приступаем к обявлению шаблона свежих записей:

sidebar1.posts = [
		<li class="lastposts">
			<div class="rubric">$title</div>
    $items = [
				<ul>
					$item = [<li><a href="$post.link" rel="bookmark" title="$lang.permalink $post.title">$post.title</a><br />
							<small>$post.date</small></li>]
			    </ul>
    ]
			</li>
]

Описание тегов смотрите в комментариях к первому сайдбару. Следующим зададим шаблон свежих комментариев:

sidebar1.comments = [
		<li class="lastcomments">
			<div class="rubric">$title</div>
    $items = [
				<ul>
					$item = [<li><a href="$link#comment-$id" title="$name $onrecent $title">$name $onrecent $title</a>: $content...</li>
					]
				</ul>
    ]
		</li>
]

Теги шаблона виджета свежих комментариев смотрите в первом сайдбаре. Следующий виджет - мета:

sidebar1.meta = [
	<li class="meta">
				<div class="rubric">$title</div>
$items = [
				<ul>
				      $item = [<li><a $class href="$link" title="$title">$icon$text</a>$subitems</li>]
				</ul>
    ]
			</li>
    $classes= [rss=rss,comments=rss-comments,foaf=foaf]
]

Остаются еще два глобальных шаблона для поддержки аяксовых виджетов:
$template.ajaxwidget = [<span class="ajaxwidget" rel="widget-$id-$sidebar"></span> $title]
$template.inlinewidget = [<span class="inlinewidget"></span> $title]

Эти два шаблона определяют html код, который будет вставлен вместо заголовка виджета ($title) и связан с javascript библиотекой LitePublisher, а именно скрипты в файле js/litepublisher/widgets.js. Первый шаблон $ajaxwidget является шаблоном для подгружаемого виджета, второй $inlinewidget является имитацией аяксового виджета и его контент не подгружается отдельным http запросом, а вставлен в html комментарий страницы, тем самым уменьшая нагрузку на сервер и ускоряя работу сайта, так как в отличии от $ajaxwidget контент $inlinewidget появляется мгновенно. Внутри этих двух шаблонов доступны следующие теги:

$id - id виджета, целое число
$sidebar - номер сайдбара, целое число
$title - заголовок виджета

Для примера приведу шаблоны для предыдущих версий:
;$template.ajaxwidget = [<a onclick="widget_load(this, $id, $sidebar)">$title</a>]
;$template.inlinewidget = [<a rel="inlinewidget" href="">$title</a>]

Все, описание шаблонов виджетов закончено.  На этом тема закончена. Все шаблоны движка полностью описаны. Одновременно вы имеете готовую рабочую тему и документацию к ней в одном файле. 

6. Дополнительные шаблоны $custom. Иногда возникает потребность в тегах, которые отсутствуют в формате темы. LitePublisher предоставляет такую возможность - добавление своих собственных тегов. Эти теги имеют вид $custom.* и могут использоваться в любом месте темы. Создадим для примера тег $custom.test:
;$custom.test = [<h2>Мой собственный тег  test</h2>]

(Убирите ;  в начале строки, чтобы шаблон раскомментировать) Тег $custom.test вы можете вставлять в любом из имеющихся шаблонов. Есть также возможность редактировать некоторые из пользовательских тегов в админке, для этого надо описать этот тег примерно следующим образом (Убирите ;  в начале строки, чтобы шаблон раскомментировать):
;$custom.test.admin = [
$title = [Установка значений для тега $custom.test]
$type = [combo]
$values = [simple test, testing tag, custom tag]
]

Шаблон для админки включает в себя тег $title - заголовок для формы редактирования, тег type, который может иметь одно из следующих значений:

text - однострочный редактор
editor - многострочный редактор
combo - комбобокс, требуется для него еще тег $values
radio - радиокнопки, требуется для них $values

$values задаётся простым перечислением через запятую текстов, которые можно выбрать в комбобоксе или радиокнопками.

Полное окончание темы. Все. Удачных разработок!