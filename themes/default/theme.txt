/*
* Lite Publisher
* Copyright (C) 2010- 2015Vladimir Yushko http://litepublisher.com/
* Licensed under the MIT (mit.txt)

Содержание:
1. Об этом документе
2. Формат about.ini
3 . О наследовании шаблонов и родительских темах
4. О формате файла темы
5. Описание тегов и шаблонов
6. Дополнительные шаблоны $custom
7. Метки $label.*

1. Этот файл является одновременно документацией и набором шаблонов темы CMS LitePublisher. В этом файле описываются и устанавливаются все шаблоны темы. 

2. Формат about.ini.
 Разборщик шаблонов начинает свой анализ с файла about.ini в папке темы. Файл about.ini обязан присутствовать в каждой теме LitePublisher, в котором обязана быть секция [about] со следующими обязательными параметрами:

name - название темы, как правило совпадает с именем папки
type - тип темы, для 4 версии это значение  litepublisher4, в предыдущих версиях он отсутствует, необходим для обратной совместимости с темами 3.xx версий
file - имя файла с шаблонами в этой же папке, может быть любым, в теме по умолчанию это theme.txt
parent - имя родительской темы (имя папки в общей папке тем themes). Как правило это default, для старых тем  - это default-old.
version - версия темы, например 4.0
author - имя разработчика темы
url адрес сайта разработчика темы
description- описание темы.

Описанные параметры являются обязательными. К необязательным параметрам относятся:
screenshot - имя файла скриншота, если отсутствует, то скриншот должен находится в файле screenshot.png
sidebar0, sidebar1 - не обязательные названия сайдбаров для админки, например "Правая колонка", "Подвал"

Если в about.ini есть языковая секция, например на русском[ru] и сайт на русском, то секция [ru] перезаписывает значения из секции [about. ]. Кодировка файла about.ini - utf-8.

3 . О наследовании шаблонов и родительских темах. В LitePublisher есть мощный механизм наследования тем. Если у темы не задана ее родительская тема, то родительской темой является тема по умолчанию default. Имя родительской темы задается в файле about.ini секция [about] параметром parent. У темы по умолчанию нет родительской темы. В разборщике тем проверяется зацикливание тем, поэтому при разработке своей темы следите, чтобы цепочка дочерних тем не зацикливалась.

Таким образом получается цепочка дочерних шаблонов. Длина цепочки наследования неограничена. Единственное естественное условие - отсутствие зацикливания.

Наследование означает, что в новой теме уже заранее известны все шаблоны - они берутся из родительской темы и разработчику новой темы достаточно только прописать свои новые шаблоны. Шаблоны, которые совпадают с родительской темой, прописывать не нужно - именно для этого и сделано наследование, чтобы разгрузить от прописывания всех шаблонов.

4. О формате файла темы.
  Тема представляет собой набор вложенных друг в друга шаблонов, таким образом получается дерево шаблонов.  
  
  Примечание для PHP програмистов: тема не является исполняемым кодом - это данные. Тема "комплируется" разборщиком в обыкновенный ассоциативный массив, где ключи массива - это название шаблона, а значение - это html текст шаблона. Все вложенные шаблоны хранятся на одном уровне. "Компиляция" темы обеспечивает высокую производительность сайта. Чтобы разборщик тем снова перечитал тему в PHP скрипте достаточно выполнить ttheme::clearcache();

 Примечание для верстальщиков: во время разработки новой темы установите плагин очистки кеша (он есть в дистрибутиве по умолчанию). Как только закончите разработку темы - деинсталируйте плагин очистки кеша. Если это не делать, то вы не сможете немедленно видеть все внесенные изменения.

Каждый из шаблонов - это готовый HTML код с тегами Litepublisher. Теги  LitePublisher - это выражения вида $object.property, где object - объект, а property - его свойство. Например $template.title или $template.content. Со списком всех доступных тегов вы можете ознакомится в документации.

В файле темы находятся объявления тегов и комментарии. Комментарии возможны в любом месте темы и обрамляются знаками /  * Комментарии удаляются при чтении файла, вложенные друг в друга комментарии запрещены - скорее всего это приведет к ошибке разборщика темы. Разборщик темы также удаляет все пробелы и переводы строк в начале и в конце шаблона. Если нужно добавить пробел в начало или конец шаблона, то следует добавлять их в виде html мнемоники, как например неразрывный пробел &nbsp; или обычный пробел &#032;

Объявление тега выглядит следующим образом: $template.name =[ html тега $template.name] Перед $template могут быть только пробелы или строка сразу должна начинатся с $template., иначе строка пропускается как комментарий.Для всех тегов можно опускать $template. для сокращения имени тега. Вместо квадратных скобок [] могут использоваться либо круглые () ЛИБО ФИГУРНЫЕ{} скобки. Выбирать можно любые парные скобки, единственное условие - чтобы в тексте шаблона все открытые скобки закрывались. То есть если вы выбрали [], то текст шаблона должен закрыть все открытые в нем квадратные скобки.

О языковых строках внутри темы. Не все тексты могут находится в $lang.* движка и вы можете для своей темы задать небольшое количество строк в файле about.ini в языковых секциях. Парсер темы заменяет все теги $about.* на соответствующие ключи файла about.ini. Таким образом можно добится интернализации вашей темы.

На верхнем уровне иерархии шаблонов находятся всего несколько шаблонов:
$template - шаблон всей страницы целиком
$template.head - шаблоны для секции head
$template.title - шаблон заголовка страницы
$template.menu - список страниц меню
$template.content - содержание, включает все основные шаблоны
$template.sidebar - шаблон сайдбара и виджетов в нем

5. Описание тегов и шаблонов.
 Начнем декларировать шаблоны верхнего уровня, и в начале объявим шаблон всей страницы целиком:
*/

$template = {@import(index.tml)}

/*
Это объявление означает, что шаблон находится в файле  index.tml - посмотрите его в той же папке, что и этот файл. Включать шаблон из файла можно двумя способами - как в этом примере @import(имя файла с шаблоном), и второй способ file=имя файла. Во втором случае объявление шаблона выглядело бы как
$template = {file=index.tml}
Какой способ выбрать остается на ваше усмотрение. Включаемые файлы могут находится только в папке темы и нигде больше. Вы можете любой из шаблонов сохранить в отдельный файл и включить его в тему директивой @import () или альтернативным способом file= В подключаемом файле тоже могут подключаться другие файлы. Уровень вложенности не ограничен. Нет проверки на зацикливание вложенных файлов - поэтому, пожалуйста, самостоятельно следите за подключаемыми файлами, а это не сложно. Комментарии в подключаемых файлах разрешены. Например вы можете указать, что сайдбар находится в файле sidebar.tml следующим образом:
$template.sidebar = [file=sidebar.tml]

 Подключать файл с шаблоном можно внутри объявления тега вместо html. Давайте откроем файл index.tml и посмотрим его текст - в нем находится шаблон всей страницы полностью. Следует заметить, что вэтом шаблоне отсутствуют какие либо вложенные шаблоны. Сделано это специально для демонстрации общей структуры темы на самом верхнем уровне. Можно немного поподробнее остановиться на каждом из тегов. Самым первым встречается тег $template.title - заголовок страницы. Установим шаблон для заголовка страницы следующим образом:
*/

$template.title = [$title $template.page | $site.name]

/*
где 
$title - это например заголовок записи
$template.page - номер страницы, если страница первая, то пустая строка, иначе "страница #"
$site.name - название сайта в настройках

Обязательно надо сказать, что после применения шаблона все пробелы и символы | обрезаются покраям. Так что если один из тегов шаблона $template.title будет пустой строкой, то это не повредит конечному результату.

 Мы уже объявили два шаблона в теме - 	$template (шаблон всей страницы) и $template.title (заголовок страницы). Далее встречаются следующие теги, которые не являются шаблонами:
$template.url - адрес этой темы, используется чтобы указать адрес файлов темы. Нигде не декларируется, так как это не шаблон.
$template.head - стандартный html для секции HEAD HTML документа. Доступен ддля редактирования в админке вид/секция head
$template.jsmerger - номер ревизии сборщика js, увеличивается на 1 после каждой сборки файлов
$template.cssmerger - номер ревизии сборщика css, увеличивается на 1 после каждой сборки файлов
$site.url - адрес сайта, без слеша / в конце адреса
$site.files - адрес файлов на сайте, без слеша / в конце адреса. Используется для указания адреса файла на сайте, по умолчанию совпадает с адресом сайта $site.url
$site.name - название сайта
$site.description - описание сайта
$site.version - номер версии движка
$site.jquery_version - номер версии библиотеки jquery подключенной к движку сайта, меняется с выходом обновлений
$site.language - язык сайта, две буквы, для русского это - ru, для английского - en
$label.homeimage - метка для вставки большого изображения на главной. Про $label смотрите в самом конце документа, а если кратко то теги $label.* используются для дополнительной разметки шаблона и полностью удаляются из сгенирированной страницы.

Далее мы встречаем теги $custom.cssfile и $custom.mainsidebar - о тегах $custom смотрите в самом конце документации. Пока заметим, что эти теги используются для выбора одного из css файлов темы и управление местом бокового сайдбара - слева или справа от главного контента.

В теле документа мы встречаем тег $template.menu - ЭТО СПИСОК МЕНЮ В ШАПКЕ САЙТА, ЗАДЕКЛАРИРУЕМ ШАБЛОН ДЛЯ ЭТОГО ТЕГА
*/

$template.menu = [
$hover = [bootstrap]
          <ul class="nav navbar-nav navbar-right">
		$item = [<li class="dropdown"><a href="$link" title="$title"               class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false" itemprop="name url">$title <span class="caret"></span></a>
		$submenu = [<ul class="dropdown-menu">$items</ul>]
		</li>]
		$single = [<li><a href="$link" title="$title" itemprop="name url">$title</a></li>]
	</ul>
]

/*
В шаблоне меню мы встретили теги:
$hover - указывает, поддерживает ли шаблон всплывающее меню . Может принимать 3 значения:
  bootstrap - двухуровневое меню, во вложенном меню дублируется родитель, чтобы обеспечить переход по ссылке (клик на верхнем уровне разворачивает/сворачивает вложенное меню)
  true - любая вложенность, родительское меню не копируется
    false - меню только одного уровня, нет вложенных подменю
    
$item - шаблон элемента списка, имеет вложенный шаблон $subitems - вложенный список
$single - шаблон одиночного меню в списке, не имеющего вложенного подменю. Важное примечание: если этот шаблон не указать, то будет использован предыдущий шаблон $item. Чтобы не возникли казусы с разработкой темы всегда декларируйте шаблон $single после шаблона $item. Если же шаблон $single совпадает с $item, то вовсе можно $single не декларировать. Исторически шаблон $single появился гораздо позже для поддержки шаблонов bootstrap, где отличаются шаблоны с подменю и без подменю.
$current - шаблон активной ссылки в списке. В настоящее время является устаревшим и не используется. Смотрите javascript поддержки всплывающего меню, в котором есть строка добавляющая класс к ссылки на текущую страницу.

В шаблоне $item доступны следующие теги:
$link - адрес страницы, включая адрес сайта
$url - адрес страницы меню, без адреса сайта
$TITLE - ЗАГОЛОВОК МЕНЮ
$ITEMS - ИСПОЛЬЗУЕТСЯ В ШАБЛОНЕ ПОДМЕНЮ $SUBMENU, КОТОРОЕ ГЕНЕРИРУЕТСЯ движком.

Про меню все. Объявим шаблоны для секции head, сразу сделав замечание, что эти шаблоны перекрываются редко и вам вряд ли понадобиться их перекрывать в новой теме.
*/

$template.head = [
  $post = [
    $rss = [<link rel="alternate" type="application/rss+xml" title="$lang.onpost $post.title" href="$post.rsscomments" />]
    $prev = [<link rel="prev" title="$prev.title" href="$prev.link" />]
    $next = [<link rel="next" title="$next.title" href="$next.link" />]
  ]
$tags = [<link rel="alternate" type="application/rss+xml" title="$context.title" href="$site.url/rss/$context.postpropname/$context.id.xml" />]
]

/*
В шаблоне $template.head находится шаблоны для полной записи $post. В данном случае шабон пустой и включает в себя 3 подшаблона:
rss - ссылка на RSS комментариев к записи
prev - ссылка на предыдущую запись
next - ссылка на следующую запись

Если нет следующей или предыдущей записи, то секции head тоже не будет ссылок. Если комментарии закрыты или отсутствуют, то ссылки на RSS комментариев тоже не будет. Эти шаблоны используются в теге $post.head. Шаблон $tags предназначен для секции head рубрик и меток, в частности ссылка на RSS постов этой рубрики или метки. использовались теги $context.*, где $context - это текущий объект запроса и будет либо рубрики или метки. На страницах записи - это будет запись. На странице записи $context и $post одинаковы.

В версии litepublisher 5.73 были добавлены новые шаблоны $template.index.home, $template.index.post и $template.index.tag - шаблоны главной страницы, записи и рубрики/метки. Как правило к этим страницам предъявляются особые требования. В предыдущих версиях движка приходилось создавать отдельные темы для главной, записи и рубрик, что вызывало определенные неудобства во время разработки новой темы. По умолчанию особого шаблона у главной, записи и рубрик/меток нет, объявим эти шаблоны:
*/

$template.index.home = []
$template.index.post = []
$template.index.tag = []

/*
Чтобы указать, что шаблон всей страницы для главной находится в файле home.tml можно сделать так:
$template.index.home = {@import(home.tml)}

 Не забывайте поместить такое объявление вне комментария сновой строки. Аналогично можно объявить и другие шаблоны. Дополнительно для главной смотрите шаблон content.home

Перейдем к  следующему очень важному тегу - $template.content. В нем содержатся шаблоны контента сайта. Перечислим эти шаблоны:
simple - шаблон для простых текстов, не имеет вложенных шаблонов и состоит из одной - двух строк
notfound - шаблон для страницы 404, не  имеет вложеных шаблонов, похож на simple
menu - шаблон страницы меню, не имеет вложенных шаблонов. Применяется также для страниц меток и рубрик.
excerpts - шаблон для анонсов, включает в себя вложенные шаблоны
post - шаблон полной записи, включает в себя много шаблонов, в том числе комментарии и форму комментариев
navi  - шаблон ссылок для постраничной навигации, имеет вложенные шаблоны
author - шаблон для страницы автора, не имеет вложенных шаблонов. Применяется при многопользовательском режиме
admin - шаблоны для админки, имеет вложенные шаблоны

Перейдем к заданию шаблонов контента. Начнем с простого - шаблон simple, который отвечает за вывод простого контента
*/

$template.content.simple = [<div class="jumbotron">$content</div>]

/*
Видим, что в этом шаблоне есть только одна переменная $content - в ней находится текст. Объявим еще один простой шаблон для страницы 404:
*/

$template.content.notfound = [
<div class="jumbotron">
				<h2>$lang.notfound </h2>
				<p>$lang.nocontent</p>
				</div>
]

/*
Здесь мы видим использование двух тегов $lang.notfound и $lang.nocontent - эти значения берутся из языковых файлов lib/languages/*.ini, $lang.* всегда доступны в любом шаблоне и позволяют теме быть интернациональной.

 Перейдем к относительно более сложному шаблону - страница меню, и можем опустить употребление $template. Объявление content.menu = [ и объявление $template.content.menu = [ абсолютно равнозначны, единственный смысл опускать $template лишь в сокращении записи. Пропускание $template не избавлляет от испобьзования символа $ во вложенных шаблонах.
*/

content.menu = [
			<div class="post" id="menu-$menu.id">
		        <h3>$menu.title</h3>
		        <div class="post-content">
					$menu.content
		        </div>
			</div>
]

/*
В этом шаблоне мы видим использование тегов $menu.*, а именно

$menu.id - уникальный id (число) меню
$menu.title - заголовок меню
$menu.content - текст страницы меню

у $menu есть и другие свойства, которые не использовались в этом шаблоне, например $menu.url, $menu.parent

Следующим, несколько усложненным шаблоном меню, можно назвать шаблон страницы автора:
*/

content.author = [
			<div class="post" id="author-$author.id">
		        <h2>$author.title</h2>
		        <div class="post-content">
					$author.content
		        </div>
			</div>
]

/*
В шаблоне использованы теги $author.*, расскажем о каждом из нихх:

$author.id - уникальный id (целое число) автора, равно $post.id
$author.name - имя автора
$author.title  - имя автора, синоним $author.name
$author.url - адрес страницы автора на вашем сайте, полный адрес будет если вначале прибавить $site.url
$author.website - адрес сайта автора
$author.email - почтовый ящик автора, конечно, лучше не публиковать
$author.md5email - строка md5 почтового ящика, можно использовать для аватара
$author.gravatar - html картинка аватара автора с сайта http://www.gravatar.com/
$author.keywords - ключевые слова страницы автора, используется в мета теге keywords
$author.description описание страницы автора, используется в мета теге description
$author.content - текст на странице автора

В версии движка 5.73 был добавлен новый шаблон content.home для главной страницы. В проекте интернет магазинов этот шаблон используется для верстки карусели между текстом и анонсами.
*/

content.home= [
$image = [
<div id="homeimage" data-image="$home.image" data-small="$home.smallimage" data-smallwidth="$home.smallwidth">
<h1>$site.name</h1>
</div>
]

$midle = [
$post = []
]]

/*
нутри content.home мы видим 2 вложенных шаблона:
$image - шаблон картинки на главной. Шаблон будет использован, если в настройках главной (админка настройки/главная) указать адрес (url) картинки.
$midle - используется если в настройках главной страницы (в админке Настройки/Главная) поставить галочку "Показывать дополнительные анонсы между текстом и основными анонсами" и будет выбрана рубрика в для этого. В $midle мы встречаем вложенный шаблон $post - шаблон анонса записи. Внутри шаблона content.home.midle.post можно использовать любые теги $post.*

Теперь можно переходить к более сложным шаблонам, каковым является шаблон записи. Можно объявить этот шаблон целиком со всеми вложенными шаблонами (формат файла темы это позволяет), но тогда будет сложнее комментировать каждый из шаблонов, поэтому постараемся обойтись минимумом вложенных шаблонов. Начнем:
*/

content.post = [
<div class="post" id="post-$post.id" itemscope itemprop="blogPost" itemtype="http://schema.org/BlogPosting">
<h3><a href="$post.link" class="self" itemprop="name url" rel="bookmark">$post.title</a></h3>
<div class="clear-after">
$post.filelist  
<div class="post-header">
<div class="meta">
<span class="fa fa-calendar" aria-hidden="true"></span> <time class="post-date" itemprop="datePublished" datetime="$post.isodate">$post.date</time>
$post.taglinks 
</div>
$post.catlinks 
</div>
</div>

<div class="entry" itemprop="text">$post.content</div>

$post.prevnext
</div>

$post.templatecomments
]

/*
Таким образом мы смогли объявить шаблон для записи обойдясь вообще без вложенных шаблонов. В шаблоне записи используется свойства обекта $post, рассмотрим их:

$post.id - уникальный id (число) записи
$post.link- полный адрес записи, включая адрес сайта
$lang.permalink - переведенная строка "постоянная ссылка на"
$post.title - заголовок записи
$post.iconlink - html ссылка на иконку, если есть
$post.date - отформатированная и переведенная дата публикации поста. о формате и шаблоне даты читайте ниже
$post.taglinks - ссылки на метки записи, для них есть свой шаблон
$post.filelist - список файлов записи, длясписка есть свой шаблон
$post.content - текст записи
$post.catlinks - ссылки на рубрики записи, тоже можно задать шаблон
$post.rsslink - html ссылка на rss комментариев к записи, есть для этого тоже шаблон				$post.prevnext - ссылки на следующую и предыдущую запись, можно задать для этих ссылок шаблон
$post.templatecomments - выводит список комментариев и форму для отправки комментария. имеет много вложенных шаблонов.

Дополнительно приведу еще список тегов записи, могущих оказаться полезными при разработке темы:
$post.day - день (01-31) публикации
$post.month - месяц, краткое название (Несколько букв)
$post.year - год публикации, 4 цифры
$post.bookmark - html ссылка на запись, для этого внутри движка используется шаблон:
 <a href="$post.link" rel="bookmark" title="$lang.permalink $post.title">$post.iconlink$post.title</a>

$post.pubdate - дата публикации в формате пригодным для RSS
$post.excerptdate - отформатированная дата публикации для анонса. Про дополнительные теги для анонсов будет рассказано когда будем рассматривать шаблоны для анонса.
$post.excerptcatlinks - ссылки категорий в анонсе, шаблон задается в секции шаблонов анонса
$post.excerpttaglinks - ссылки меток в анонсе, шаблон задается в секции шаблонов анонса
$post.excerptfilelist - список файлов, используется шаблон для анонсов
$post.firstimage - первая картинка в записи, если есть. Используется в анонсах, чтобы не показывать остальные картинки
$post.excerptcontent - текст анонса вместе со ссылкой "Далее"
$post.tagnames - метки, перечисленные через запятую, без ссылок, только названия
$post.catnames -рубрики, перечисленные через запятую, без ссылок, только названия
$post.head - html для секции head
$post.keywords - ключевые слова, по умолчанию равны меткам
$post.description - описание записи, по умолчанию это обрезанный анонс
$post.moretitle - текст для ссылки "Далее"  в анонсе
$post.morelink - ссылка "Далее" в анонсе
$post.title2 - альтернативный заголовок записи, обычно это пустая строка
$post.rss - текст записи в ленте RSS
$post.commentscount - количество комментариев к записи
$post.commentslink - html ссылка на комментарии к записи
$post.iconurl - адрес иконки, если она есть
$post.idurl - уникальный id адреса поста, в шаблонах неиспользуется
$post.parent - уникальный id родительского поста, по умолчанию = 0, нигде не используется, может быть пригодится в будущем
$post.revision - номер ревизии, в шаблонах неиспользуется, нужен для автообновления фильтрованного контента
$post.password - пароль записи, используется если способ доступавыбран как "оодиночный пароль"
$post.teaser - текст после анонса, если нет тега more внутри записи, то пустая строка
$post.contentpage - текст записи на текущей странице при многостраничном контенте
$post.pagescount - количество страниц текста в записи, имеет смысл если текст был разбит тегом<!--nextpage-->
$post.countpages - максимум между количеством страниц текста и страниц комментариев
$post.commentpages - количество страниц комментариев, обычно это 1
$post.lastcommenturl - адрес последней страницы, если страниц нет, то адрес записи
$post.image - url первой картинки в записи, если нет, то пустая строка
$post.thumb - url первой миниатюры в записи, если нет, то пустая строка
$post.author - уникальный id автора, по умолчанию 0, 1 всегда у главного администратора
$post.authorname - имя автора записи, если нет автора, то значение тега $site.author
$post.authorlink - html  ссылка на автора /users.htm?id= id автора, если в профиле автора есть сайт, то будет редирект на сайт автора
$post.authorpage - html  ссылка на страницу автора, если нет страницы - то пустая строка

Последние теги относятся к странице автора, но поскольку вам может не хватить тегов для автора, то в шаблонах записи вы можете использовать свойства сателитного объекта $author.* Ознакомится с доступными тегами вы можете в описании шаблона content.author, все эти теги также доступны в шаблоне записи. Безусловно, эти теги имеют смысл только при многопользовательском режиме (включается в админке на странице настройки/безопасность).

Получился обширный список тегов, которые вы можете использовать в шаблоне записи. Некоторым из тегов записи вы можете задать свои шаблоны, а именно вот этим:

$post.date - отформатированная и переведенная дата публикации поста
$post.filelist - список файлов записи, длясписка есть свой шаблон
$post.taglinks - ссылки на метки записи
$post.catlinks - ссылки на рубрики записи
$post.more - шаблон для внутристраничной ссылки из анонса, то есть куда ссылается ссылка "Далее" из анонса
$post.rsslink - ссылка на rss комментариев к записи
$post.prevnext - ссылки на следующую и предыдущую запись
$post.templatecomments - выводит список комментариев и форму для отправки комментария. имеет много вложенных шаблонов.

Теперь можно задать детальные шаблоны для каждого из приведенных в списке тегов, в конце рассмотрим шаблон комментариев, как самый сложный. Начнем по порядку - с шаблона формата даты публикации
*/

content.post.date = [d.m.Y]

/*
Как видим формат простой - это параметры для php функции date, и вданном случае это d.m.Y, дата будет переведена на язык сайта. Объявим внутристраничную ссылку для ссылки "Далее..." из анонса записи:
*/

content.post.more = [<span id="more-$post.id"></span>]

/*
Как видим шаблон примитивный и его объявление является формальностью. Следующим тегом идет $post.taglinks, зададим шаблон для списка меток
*/

content.post.taglinks = [
<div class="post-tags">
<span class="fa fa-tags" aria-hidden="true"></span>
<span class="tags-title">$lang.tags:</span>
 $item = [ <a href="$link">$title</a>]
  $divider = [,&#32;]
</div>
]

/*
Шаблон получился не сложным, в нем присутствует строка $lang.tags - "Метки", а также два вложенных шаблона:
$ITEM - ШАБЛОН ОДНОЙ МЕТКИ
$divider - шаблон разделителя ссылок

 Все. Симметрично устроен шаблон для рубрик. Объявим его
*/

content.post.catlinks = [
<div class="post-categories" id="post-categories-$post.id">
<span class="fa fa-tags" aria-hidden="true"></span>
<span class="cats-title">$lang.categories:</span>
$item = [ <a href="$link" class="category">$title</a>]
$divider = [,&#32;]
</div>
]

/*
Вся разница между двумя этими шаблонами в $lang - в первом случае это "Метки", а во втором - "Рубрики".Для каждой метки и рубрики в шаблоне $item доступны следующие теги:

$id - уникальный id метки или рубрики
$link - адрес, включает адрес сайта
$url - адрес без адреса сайта
$title - название (заголовок) метки или рубрики
$itemscount - количество записей в метке или рубрике
$parent - уникальный id родительской метки или рубрики, имеет смысл при вложенных метакх и рубриках
$icon - html иконка, если есть

Перед тем, как расматривать шаблон списка файлов рассмотрим два несложных шаблона - ссылка на RSS и ссылки на следующую и предыдущую запись.
*/

content.post.rsslink = [<span class="rsscomments"><a href="$post.rsscomments" title="$lang.subscribetorsscomments" ><span class="fa fa-rss" aria-hidden="true"></span> $lang.subscribetorsscomments</a></span>]

/*
В этом шаблоне встречаются два тега: $post.rsscomments - это адресс ссылки RSS комментариев записи, а $lang - строка "Подписаться на RSS комментариев". Все более чем просто. Также несложный шаблон ссыллок на следующую и предыдущую запись:
*/

content.post.prevnext = [
								<div><ul class="pager">
								$prev = [<li class="previous"><a rel="prev" href="$prevpost.link">&larr; $lang.prev $prevpost.title</a></li>]
								$next = [<li class="next"><a rel="next" href="$nextpost.link">$nextpost.title $lang.next  &rarr;</a></li>]</ul></div>
]

/*
В шаблоне есть всего два вложенных шаблона:
$prev - шаблон ссылки на предыдущую запись
$next - шаблон ссылки на следующую запись

В каждом из этих двух шаблонов доступны (и вобщем шаблоне) теги 

$prevpost - предыдущая запись
$nextpost - следующая запись

Разрешено использовать любые теги для записи, здесь же использовались уже ранее встречавшиеся свойства записи link  и title. Перейдем к более сложному и важному шаблону - шаблон списка файлов.
*/

content.post.filelist = [
<div class="filelist-all filelist-$count" id="files-$post.id">
$files = [<div class="files-block filelist-file"><ul>
$file = [<li class="file"><a id="postfile-$post.id-$id" href="$link" data-file="$json" title="$description">$title</a></li>]
</ul></div>]
$images= [<div class="files-block filelist-image">
$image = [<span class="image"><a class="photo" id="postfile-$post.id-$id" rel="prettyPhoto[gallery-$post.id]" itemprop="image" href="$link" title="$title" data-file="$json">$preview</a></span>]
$preview = [<img class="photo" src="$preview.link" alt="$title" title="$description" />]
</div>]
$videos = [<div class="files-block filelist-video">
$video = [<span class="image"><a title="$title" rel="video" class="videofile" id="postfile-$post.id-$id" href="$link" data-file="$json">$preview<span class="fa fa-file-video-o video-fallback">$title</span></a></span>]
</div>]
$audios = [<div class="files-block filelist-audio">
  $audio = [<audio id="postfile-$post.id-$id" src="$link" type="$mime" controls="controls"></audio>]
</div>]
$flashs = [<div class="files-block filelist-flash">
$flash = [<div class="flash-holder">
<object type="application/x-shockwave-flash" data="$link" width="$width" height="$height" id="flashplayer-$id" name="flashplayer-$id">
<param name="movie" value="$link" />
<param name="allowfullscreen" value="true" />
<param name="allowscriptaccess" value="always" />
<param name="menu" value="false" />
<param name="wmode" value="transparent" />
<param name="FlashVars" value="autostart=true" />
</object>
</div>]
</div>]

</div>]

/*
Мы видим объявление в списке файлов шаблоны для разных типов. Несложно догадатся, какой шаблон отвечает за какой тип файлов

$file - отсутствует тип файла, скорее всего это бинарник
$image - картинка, по умолчанию к картинкам создаются миниатюры. Этот шаблон для картинок сразу организует их в галерею
$preview - шаблон для миниатюр, они используются в галерее
$audio - шаблон для аудиофайлов, этот шаблон сразу подключает плеер
$video - шаблон для видеороликов. Видеоплеер будет запущен в открывшейся галерее после клика по миниатюре видеоролика. Если у видео отсутствует миниатюра, то будет использована общая миниатюра для видео
$flash - шаблон для флеш. Флеш ролик будет встроен прямо в страницу

LitePublisher генерирует список файлов на основе этих шаблонов, файлы сортируются по типам. Внутри шаблона длялюбого типа файла доступны свойства файла, а именно:
$id - уникальный id файла (число)
$media - тип файла, строка имеет одно из следующих значений: 'bin','image','icon','audio','video','flash', 'document','executable','text','archive'
$parent - уникальный id родительского файла, в шаблонах = 0, кроме шаблона для миниатюр - $preview
$preview - уникальный id миниатюры, если миниатюры нет, то равен 0. Имеет смысл только для картинок
$icon - уникальный id иконки для этого типа файлов. В настоящее время не используется и равно 0.
$author - уникальный id автора файла. Имеет смысл при многопользовательском режиме.
$idperm - уникальный id ограниченного доступа к файлу. В шаблонах не используется
$size - размер в байтах файла
$posted - дата добавления файла
$mime - mime тип файла, строка, не всегда возможно коректное значение
$filename - имя файла, включая папку относительно общей папки файлов. Полный адрес к файлу получается $site.files/files/$filename
$link - полный адрес к файлу, включает адрес сайта
$title - название файла, если не было задано, то равно имени файла
$description - описание файла, пустая строка, если не задано 
$keywords - ключевые слова для файла, пустая строка, если не задано
$hash - строка равна закодированному хешу md5 файла (22 букв и цифр), используется для фильтрации копий файлов, в шаблонах не используется
$height - высота картинки, для других типов файлов = 0
$width - ширина картинки, для других типов файлов = 0
$index - номер файла в списке начиная с нуля
$typeindex - номер файла в подсписке файлов по типам, начиная с нуля
$json - строка, полученная json кодированием всех свойств файла (выше их перечислили) за исключением 3 свойств: $title, $description, $keywords. Эти свойства исключены из за дублирования и их размера. в этой строке все символы " заменены на &quot;  - сделано это для использования $json в атрибутах тегов, здесь в шаблоне это data-file="$json"

Кроме свойст файла доступны еще 2 тега:
$count - общее количество файлов в посте
$subcount - количество файлов одного типа в каждом из шаблонов. Если например кроме картинок нет других файлов, то $subcount совпадает с $count, справидливо для любых типов файлов.

Вы можете использовать любую комбинацию этих значений в шаблоне файлов. Как видно из верстки, сам список и файлы по типам разделены блочными элементами с переносом строк (смотрите файл js/litepublisher/filelist.css). Если в посте много картинок, то такая верстка работает отлично, разграничивая блок с миниатюрами и текстом поста. В случае одной - двух фоток в посте выглядит уже не так привлекательно из за пустого места справа от миниатюр. Чтобы разрулить оба варианта в движок включен скрипт js/litepublisher/filelist.js, который ориентируясь на эту верстку удаляет div'ы вокруг миниатюр и добавляет класс files-block к первому div или p после миниатюр. Тогда текст поста получается  сразу справа от миниатюр. Учитывайте это в своей разработке. Скрипт можно всегда удалить или добавить в сборщике js (админка вид/сборщик js).

По умолчанию в движок включена галерея prettyPhoto, клон известной галереи lightbox для jquery, подробную информацию о настройках и возможностях галереи вы можете узнать на официальном сайте галереи (http://www.no-margin-for-errors.com). Вы, безусловно, можете использовать любую другую галерею, но надо заметить, что эта галерея обладает своим апи для расширений, может организовывать не только картинки, но и флэш, html, видео, видео ютьюба. В этом шаблоне картинки организованы по галереям для каждого поста, то есть в одном посте все его картинки будут в одной галерее, в следующем посте будет следующая галерея. За это отвечает шаблон для prettyPhoto rel="prettyPhoto[gallery-$post.id]" В сборщик js файлов по умолчанию включен следующий javascript (вы всегда можете это отредактировать в админке) для инициализации галереи:

  $(document).ready(function() {
    $("a[rel^=\'prettyPhoto\']").prettyPhoto({
      social_tools: false
    });
  });

Файл стилей галереи подключается в сборщике css, который вы можете найти в админке в подменю "Вид". Также сборщик стилей подключает файл /js/litepublisher/css/filelist.min.css, в котором находятся стили для списка файлов. Таким образом, используется один шаблон и стили к нему в других темах и нет необходимости копировать стили для списка файлов для своей темы.

Обратите внимание - в шаблоне ссылки картинки стоит class="photo" Сам же класс photo отсутствует в стилях и класс был добавлен для поддержки микроформатов таких, как hproduct, hlisting. Пожалуйста оставьте класс photo в своих шаблонах, потому что это поможет поддержке микроформатов.

Кроме скрипта галереи в сборщике javascript включены скрипты аудио и видео плееров. Рассмотрим их подробнее.  Используется библиотека MediaElement.js (http://mediaelementjs.com/), которая поддерживает html5 и флеш плееры одновременно. Скрипт litepublisher анализирует список файлов и для аудио файлов сразу встраивает аудиоплеер. Видео обслуживается по другому - видеоплеер будет открываться внутри галереи по клику по миниатюре. Таким образом открытие картинок и видео происходит симметричным образом, экономя место в основном контенте страницы. Размеры видео плеера задаются в админке настройки/файлы. Исходный текст jquery скрипта можете найти в файле /js/litepublisher/players.js, который подключается сборщиком javascript движка (в админке можете отредактировать список файлов на странице Вид/Сборщик JS). Могут возникнуть вопросы про миниатюры для видео - по умолчанию, для видео у которого нет миниатюры,  используется  файл js/litepublisher/icons/videoplayer.jpg, но вы всегда можете поменять миниатюры у файлов в админке. Движок не имеет средств извлечения миниатюр из видео, так как задача анализа видео, выходит  далеко за рамки php скриптов и требует наличия на хостинге инструментов подобных ffmpeg, который не предоставляется на шаред хостинге.

Для многих список файлов в теме является очень важным вопросом, поэтому за дополнительной информацией обращайтесь в тикет систему по адресу:
http://litepublisher.ru/

Переходим к шаблону списка комментариев  content.post.templatecomments, который включает в себя множество шаблонов, а именно:

$closed - шаблон сообщения о закрытом комментировании
$form - форма отправки комментария
$confirmform - форма подтверждения комментария
$comments - шаблон списка комментариев
$pingbacks - список пингбеков

Будем разбирать каждый из этих шаблонов по нарастанию сложности. Самый простой шаблон - сообщение закрыто:
*/

content.post.templatecomments.closed = [<p class="text-center red">$lang.closed</p>]

/*
Внутри шаблона встречается тег $lang.closed - строка "Комментирование закрыто". Далее посмотрим на шаблон формы комментирования - в зависимости от настроек записи будет выдаваться сообщение о закрытом комментировании либо форма отправки. Объявим форму комментирования для зарегистрированных посетителей и гостей:
*/

content.post.templatecomments.regform = [
<div id="before-commentform">$mesg</div>
<h4>$lang.leavereview</h4>
<form action="$site.url/send-comment.php" method="post" id="commentform" role="form">
<div class="form-group"><label for="comment">$lang.comment</label>
<textarea name="content" id="comment" class="form-control"></textarea></div>

<div class="hidden">
<input type="hidden" name="postid" value="$postid" />
<input type="hidden" name="antispam" value="$antispam" />
</div>

<div class="text-center"><div class="center-block"><button class="btn btn-primary" name="submitbutton" type="submit" id="submit-button">$lang.send</button></div></div>
</form>
<script type="text/javascript">
ltoptions.theme.comments = $.extend(ltoptions.theme.comments, {
button: '<button type="button" class="btn btn-default tooltip-toggle" data-moder="%%name%%" title="%%title%%"><span class="fa moder-%%name%%" aria-hidden="true"></span> <span class="sr-only">%%title%%</span></button>'
});
</script>
]

/*
Простая форма включает в себя только один редактор текста. Этим можно было бы и ограничется, но нам нужно предупредить зарегистрированного пользователя от чьего имени он оставляет комментарий, для анонимных гостей выдать другое сообщение. Также желательно бы разместить дополнительную информацию о возможности регистрации, в том числе и через социальные сети. Просто говоря - нужно место, где это поместить. Для этого предусмотрен div с тегом $mesg - текст подсказки, его можно всегда поправить в админке на странице Настройки/Комментарии.

 Также в этом шаблоне следует указать селекторы jquery отличные от темы по умолчанию. О том, что и как  следует ли делать это в принципе пойдет разговор после обяснений всех шаблонов комментариев, так как рекомендации по вставке кода будут касаться всех объявленных шаблонов. Вставляемый код будет простым javascript.

В движке предусмотрена возможность оставлять комментарии без регистрации, но с указанием email и имени комментатора. Вот эта форма:
*/

content.post.templatecomments.form = [
<div id="before-commentform">$mesg</div>
<h4>$lang.leavereview</h4>
<form action="$site.url/send-comment.php" method="post" id="commentform" role="form">
<div class="form-group"><label for="text-name">$lang.name</label>
<input type="text" class="form-control" name="name" id="text-name" value="$name" /></div>
<div class="form-group"><label for="text-email">$lang.email</label>
<input type="text" class="form-control" name="email" id="text-email" value="$email" /></div>

<div class="form-group"><label for="text-url">$lang.url</label>
<input type="text" class="form-control" name="url" id="text-url" value="$url" /></div>

<div class="form-group"><label>
<input type="checkbox" class="form-control" name="subscribe" id="checkbox-subscribe" $subscribe /> $lang.subscribe</label></div>

<div class="form-group"><label for="comment">$lang.comment</label>
<textarea name="content" id="comment" class="form-control"></textarea></div>

<div class="hidden">
<input type="hidden" name="postid" value="$postid" />
<input type="hidden" name="antispam" value="$antispam" />
</div>

<div class="text-center"><div class="center-block"><button type="submit" name="submitcomment" class="btn btn-primary" id="id-submitcomment">$lang.send</button></div></div>
</form>]

/*
Шаблон не смотря на свой объем является простым, так как не включает в себя вложенных шаблонов. В шаблоне формы использовались следующие теги:

$name - имя комментатора
$email - E-Mail комментатора
$url - адрес сайта комментатора
$subscribe - подписка по E-Mail, пустая строка либо checked="checked"
$content - текст комментария
$postid - уникальный id записи к которой отправляется комментарий
$antispam - строка созданная движком для защиты от спама

Если комментатор первый раз оставляет комментарий, то $name, $email, $url являются пустыми строками, а если комментатор уже отправлял свой комментарий, то они заполняются соответствующими значениями. Особняком стоит значение $subscribe - подписка на E-Mail новых комментариев: для первый раз комментирующего это значение выставляется в зависимости от настроек сайта, для повторного комментатора в том значении, в котором он последний раз комментировал. Также обратите ваше внимание на вставку javascript, это файл $site.files$template.jsmerger_comments - он обрабатывает нажатия кнопок цитирования в списке комментариев. Поскольку эти кнопки цитирования имеют смысл только при открытом комментировании, то и подключения скрипта для этих кнопок естественно расположить в форме комментирования. G\По умолчанию сборщик js файлов содержит для комментариев файл из дистрибутива /js/litepublisher/comments.min.js и секкцию comments из языкового файла. Языковой файл нужен для текста цитирования.

Следующей после отправки комментария находится форма подтверждения оного. Зададим шаблон для формы подтверждения:
*/

content.post.templatecomments.confirmform = [
<h3>$lang.checkspam</h3>
<form name="preform" method="post" action="" role="form">
<div class="text-center"><div class="center-block"><button type="submit" class="btn btn-default" name="submit1">$lang.robot</button></div></div>
</form>
<form name="form" method="post" action="" role="form">
<div class="text-center"><div class="center-block"><button type="submit" class="btn btn-class" name="submit2">$lang.human</button>
<input type="hidden" name="confirmid" value="$confirmid" />
</div></div>
</form>]

/*
Как видим этот шаблон состоит из двух форм - ложной формы для роботов и форма для людей. В форме для людей находится  один шаблон:
$confirmid - строка с набором цифр и букв для подтверждения комментария. Для каждого комментария генерируется случайно своя собственная строка, эту комбинацию невозможно угадать и она становится известной только после заполнения формы отправки комментария. Такая простая защита отсеивает спам и позволяет людям спокойно отправлять комментарии.

Перейдем к главному - список комментариев и сам шаблон комментария. Есть два списка комментариев: одобренных и задержанных. Главным, безусловно, является список одобренных, а второстепенным является список задержанных комментариев. Шаблон списка включает в себя следующие шаблоны:
$count - шаблон количества комментариев на запись
$comment - шаблон комментария

Начнем объявлять шаблоны с шаблона количества:
*/

content.post.templatecomments.comments.count = [
  <h4><meta itemprop="interactionCount" content="UserComments:$count"/>$count $lang.topost: $post.title</h4>
  ]

/*
В шаблоне количества комментариев нам доступны следующие теги:

$post.* - все свойства записи $post, здесь использовали title -заголовок записи
$count - собствено число комментариев, уже отформатированое для языка (0 = нет комментариев, 1 = 1 комментарий, и так далее)
$lang.topost - строка "на запись"

А вот и сам список комментариев:
*/

content.post.templatecomments.comments = [
<script type="text/javascript">ltoptions.theme.commentlist = "#commentlist";</script>
<a id="comments"></a>
<div id="commentlist" data-start="$from">
  $comment
</div>]

/*
Как видим шаблон простой и в нем использовались 2 шаблона:
$from - число откуда начинается отсчет комментариев, обычно это 1, но при большом количестве комментариев и разбивки на страницы это число равно например 101
$comment - шаблон комментария

Обратите внимание на строку:
<script type="text/javascript">ltoptions.theme.commentlist = "#commentlist";</script>

Она предназначена для связи с javascript, которые смогли бы найти список комментариев. Указано значение "#commentlist" - id списка, которое также является селектором для jquery.

Объявим шаблон для списка задержанных - он является почти полной копией списка одобренных:
*/

content.post.templatecomments.holdcomments = [
<h4 id="holdcomments">$lang.hold</h4>
<div id="holdcommentlist" data-start="1">
  $comment
</div>
]

/*
Следует обратить внимание на  атрибут start тега ol, который не является валидным для xhtml, но является валидным в html5 и html4. Поскольку эта тема имеет doctype xhtml, то шаблон списка комментариев не пройдет валидацию. LitePublisher предоставляет способ обойти это ограничение. Следует отказаться от тега ol в пользу тега ul без атрибута start, а в  стилях прописать list-style: none; и в шаблоне комментария использовать $index для нумерации комментариев. Передекларируем список комментариев (формат темы это позволяет - последнее объявление шаблона будет использовано в конечном итоге)

Объявим шаблон комментария:
*/

content.post.templatecomments.comments.comment = [
<div $class1=[] $class2=[] class="comment-item" id="comment-$comment.id" itemprop="comment" itemscope itemtype="http://schema.org/UserComments">
<div class="container-fluid"><div class="row">
<div class="col-sm-5" itemprop="creator" itemscope itemtype="http://schema.org/Person"><span class="comment-index">$index</span> <span itemprop="name">$comment.authorlink</span></div>
<div class="col-sm-3 comment-datetime"><span class="date">$comment.date = [d M Y]</span> $lang.attime <time class="time" itemprop="commentTime" datetime="$comment.iso">$comment.time</time></div>
<div class="col-sm-4">
 <div class="moderate moderationbuttons btn-group" data-idcomment="$comment.id" data-idauthor="$comment.author">
$quotebuttons = [
<button type="button" class="btn btn-default tooltip-toggle replycomment" data-idcomment="$comment.id" data-authorname="$comment.name" title="$lang.reply"><span class="fa fa-reply" aria-hidden="true"></span> <span class="sr-only">$lang.reply</span></button>
<button type="button" class="btn btn-default tooltip-toggle quotecomment" data-idcomment="$comment.id" data-authorname="$comment.name" title="$lang.quote"><span class="fa fa-copy" aria-hidden="true"></span> <span class="sr-only">$lang.quote</span></button>]
</div>
</div>
</div></div>
<div id="commentcontent-$comment.id">
<ins datetime="$comment.iso" itemprop="commentText">$comment.content</ins>
</div>
</div>]

/*
В шаблоне комментария мы видим несколько вложенных шаблонов и активное использование тегов $comment.* Рассмотрим вложенные шаблоны:
$class1 - html класс нечетных комментариев
$class2 - html класс четных комментариев (в данном примере класс отсутствует)
$index - целое число, индекс комментария, используется если, к примеру, был объявлен ранее шаблон списка ul
$indexplus- тоже самое , что и $index но на 1 больше, поэтому нумерация начнется с 1
$comment.date - шаблон даты комментария, не обязательный шаблон
$quotebuttons - вложенный шаблон кнопок цитирования, имеют смысл при открытом комментировании. Если комментирование отключено, то эти кнопки не показываются

Как видим вложенных шаблонов немного, зато много свойств у $comment, перечислим их

$comment.id - уникальный id (число) комментария
$comment.post - уникальный id (число) записи для которой комментарий
$comment.author - уникальный id (число) автора комментария
$comment.parent - уникальный id (число) родительского комментария, в настоящее время не используется и = 0
$comment.posted - дата добавления в формате timestamp (целое число)
$comment.status - статус комментария, только в бд версии, возможные значения: 'approved','hold','spam','deleted'
$comment.content - отфильтрованный текст комментария
$comment.authorlink - html ссылка на автора комментария, может быть только имя комментатора в зависимости от настроек сайта
$comment.date - отформатированная строка дата отправления комментария, для этого тега можно задать свой шаблон. Если шаблони не задан, то используется формат по умолчанию
$comment.time - время отправления комментария, используется шаблон даты "H:i" (час:минуты)
$comment.localstatus - состояние комментария, переведенная на язык строка, например "одобрен", "задержан"
$comment.website - адрес сайта комментатора
$comment.url - адрес записи с (#) внутристраничной ссылкой на комментарий
$comment.posttitle - заголовок записи для которой комментарий
$comment.rawcontent - неотфильтрованный текст комментатора
$comment.IP - IP адрес комментатора
$comment.md5email - md5 хеш E-Mail комментатора
$comment.gravatar - html картинка аватара комментатора с сайта http://www.gravatar.com/

Понятно, что не все перечисленные теги используются в шаблоне комментария, а только их часть. Следует остановиться на шаблоне даты $comment.date - вы можете просто вставить этот тег в шаблон, а если хотите задать свой собственный шаблон даты, то вам следует это сделать привычным для формата темы способом $comment.date = [ваш формат даты] Формат даты - это формат даты для функции PHP date, в данном примере это "d.m.Y"

Обратим внимание на HTML разметку, в частности - шаблон hCard, в нашем случае это <span class="vcard author"> Особого значения это не имеет, но вероятно поможет поисковикам более благосклонно относится к вашему сайту потому, что поисковики обрабатывают микроформаты hCard.

Следующий момент - пустой тег div с классом moderationbuttons. Он предназначен для кнопок модерирования, которые будут вставлены скриптом (js/litepublisher/moderate.js) для  залогиненных поситителей в зависимости от прав. Для администратора и модератора будут добавлены все кнопки (задержать, одобрить, удалить, редактировать) для каждого комментария. Для рядовых комментаторов могут быть показаны кнопки редактировать и/или удалить в зависимости от настроек (в админке настройки/комментарии галочки прав).  Разберем шаблон
<div class="moderationbuttons" data-idcomment="$comment.id" data-idauthor="$comment.author"></div>

В атрибутах data* передана информация о текущем комментарии, а именно:
$comment.id - уникальный id комментария
$comment.author - уникальный id автора

Вы должны обязательно вставить эти атрибуты для передачи данных скрипту. Чтобы HTML не ругался на вашу тему, она должна поддерживать RDFa  (указывается в DOCTYPE) или быть HTML 5 версии. Чтобы вместо ряда кнопок первоначально показывалась одна кнопка "E", следует добавить класс hidden к  moderationbuttons. Тогда будет видна только одна кнопка E, по клику заменяется на кнопки модерирования.

Чтобы скрипт (js/litepublisher/moderate.js) смог коректно отработать, ему нужна дополнительная информация о структуре HTML списка комментария, необходимо в скрипт передать jquery селекторы. Скрипт следует вставлять в шаблон content.post.templatecomments.regform задекларированный ранее. Здесь, в теме по умолчанию отсутствует  скрипт потому, что  (js/litepublisher/moderate.js) имеет значения по умолчанию равные теме по умолчанию. Продемонстрируем полный текст возможного скрипта:

<script type="text/javascript"> ltoptions.theme.comments = $.extend(true, ltoptions.theme.comments, {
        // список комментариев в виде селектора (включает символ # для id списка)
        comments: "#commentlist",
        // селектор списка задержанных комментариев, включая символ# для id
        hold: "#holdcommentlist",
        // селектор одиночного комментария, полный получается если прибавить id, пример#comment-357
        comment: "#comment-",
        // селектор текста комментария, к нему прибавляется id, пример #commentcontent-357
        content: "#commentcontent-",
        // селектор владельца, куда будут вставлены кнопки модерирования, в теме по умолчанию это <div class="moderationbuttons" ...
        buttons:".moderationbuttons",
        // шаблон кнопки модерирования, %%title%% будет заменен на название кнопки (одобрить, задержать, редактировать, удалить)
        button: '<button type="button" class="button"><span>%%title%%</span></button>',
        //класс кнопки "Ответить"
        replyclass: "replycomment",
        //клас кнопки "Цитировать"
quoteclass : "quotecomment",
        // селектор формы комментариев, здесь id тега form
        form: "#commentform",
        // селектор редактора, то есть textarea формы
        editor: "#comment"
      });
</script>
      
Естественно, что в вашей теме не потребуется указывать все эти селекторы, если они совпадают с темой по умолчанию. Например, если у вас будет другой только шаблон кнопки модерирования, то достаточно указать только ее одну:

<script type="text/javascript"> ltoptions.theme.comments = $.extend(true, ltoptions.theme.comments, {
        button: '<a href=#">%%title%%</a>'
      });
</script>

Напомним, что этот скрипт следует добавлять к шаблону content.post.templatecomments.regform задекларированный ранее.

С комментариями практически все - остались только пингбеки. Вот шаблон пингбеков:
*/

content.post.templatecomments.pingbacks = [
<h4>$lang.pingbacks</h4>
<ol class="commentlist" start="1">
  $pingback = [<li id="pingback-$pingback.id"><a href="$pingback.url">$pingback.title</a></li>]
</ol>]

/*
Вшаблоне пингбеков мы видим вложенный шаблон пингбека. На самом деле получается несколько урезанный шаблон комментариев. Внутри шаблона пингбека используется теги $pingback.*, перечислим свойства пингбека:

$pingback.id - уникальный id (число)
$pingback.url - адрес пингбека, то есть адрес сайт с которого стоит ссылка на запись
$pingback.title - заголовок страницы, на которой стоит ссылка на запись
$pingback.post - уникальный id (число) где находится пингбек
$pingback.posted - дата в формате sql  или timestamp (зависит от версии движка)
$pingback.ip - IP адрес откуда пришел пингбек

С комментариями все. Осталось только рассказать в какой последовательности генерируется контент. Вначале идет список одобренных комментариев, потом задержанные (если есть), потом пингбеки, и в конце форма добавления комментария.

Таким образом мы закончили описывать шаблон полной записи. Перейдем к описанию шаблонов анонсов. На верхнем уровне есть 3 шаблона анонсов:
content.excerpts - шаблон списка анонсов, как правило пустая строка
content.excerpts.excerpt - шаблон одного анонса записи, включает в себя вложенные шаблоны
content.excerpts.lite - шаблон анонсов для lite (облегченного) режима

Немного о шаблоне content.excerpts - это html, который может обрамлять анонсы, как правило отсутствует. Например вы можете задать такой шаблон до и после объявления вложенного тега $excerpt (он же content.excerpts.excerpt):
*/

content.excerpts = [
<div class="row">
$excerpt = [
<div class="anpost col-xs-6 col-lg-4"id="post-$post.id">
<h4 class="anpost-title"><a href="$post.link" class="post-link poptitle" rel="bookmark">$post.title</a></h4>
<div class="anpost-subtitle">$post.excerptcontent $post.morelink = [<!--no more-->]</div>
<div class="anpost-content">
$post.firstimage = [<div class="anpost-image"><a class="photo" href="$post.link" data-image="$link"><img src="$preview.link" alt="$post.title" /></a></div>]
<div class="anpost-body">
$post.catlinks

<div class="anpost-item">
<span class="fa fa-calendar" aria-hidden="true"></span>
<span class="anpost-item-title">$lang.posted</span>
				<span class="post-date">$post.excerptdate = [d.m.Y]</span>
</div>

<div class="anpost-item"><span class="post-comments">$post.commentslink</span></div>

<div class="more-button anpost-item"><a href="$post.link#more-$post.id" class="btn btn-primary" role="button">$lang.moredetails</a></div>

</div>
</div>
</div>
]
</div>
]

/*
Как видим, мы использовали ранее известные теги $post.* по шаблону полной записи. То есть тег $post.catlinks будет использовать шаблон полной записи для рубрик. Если вы хотите, чтобы шаблоны в анонсе отличались от шаблонов полной записи, то вы это можете сделать. Например вместо $post.catlinks поставить тег $post.excerptcatlinks. Также вы можете безопасно вставлять теги для анонсов - если вы не оббявите соответствующие шаблоны для анонсов, то будут использованы шаблоны для полной записи. Перечислим шаблоны для анонса:

content.excerpts.excerpt.date - $post.excerptdate, шаблон формата даты для анонса в формате для PHP функции date()
content.excerpts.excerpt.catlinks - $post.excerptcatlinks, шаблон для рубрик в анонсе, имеет точно такой же формат как и для шаблона рубрик в полной записи
content.excerpts.excerpt.taglinks - $post.excerpttaglinks, шаблон для меток в анонсе, имеет точно такой же формат как и для шаблона меток в полной записи
content.excerpts.excerpt.filelist - $post.excerptfilelist, шаблон для списка файлов в анонсе, имеет точно такой же формат как и для шаблона списка файлов в полной записи
content.excerpts.excerpt.firstimage - $post.firstimage, шаблон для первой картинки в записи. Используется для минимизации анонса, когда надо показать всего лишь одну картинку

Из специфических только для анонса можно выделить шаблон $post.morelink (он же content.excerpts.excerpt.morelink) - это шаблон ссылки "Далее" в анонсе. Этот тег можно вставлять только для объявления шаблона, без шаблона его не следует вообще употреблять. В шаблоне анонса записи ммы объявили вложенный шаблон для тега $post.morelink. Если у записи нет анонса, то этот тег возвращает пустую строку. Этот тег автоматически вставляется внутри $post.excerptcontent и поэтому его не следует просто так ставить - тогда скорее всего появится две ссылки "Далее".

Следует наверно продемонстрировать, как изменить один из шаблонов, например картинки в списке файлов анонса :
content.excerpts.excerpt.filelist.image = [<span class="image"><a class="photo" id="postfile-$post.id-$id" rel="prettyPhoto[gallery-$post.id]" itemprop="image" href="$link" title="$title" data-file="$json">$preview</a></span>]

На самом деле мы задали абсолютно такой же шаблон как и восновном списке, но вы можете изменить шаблон по своему вкусу.

В шаблоне анонса мы объявили шаблон первой картинки:
$post.firstimage = [<div class="anpost-image"><a class="photo" href="$post.link" data-image="$link"><img src="$preview.link" alt="$post.title" /></a></div>]

Если взаписи есть картинки, то тег $post.firstimage с помощью этого шаблона выведет первую картинку. Удобно, когда требуется вывести в анонсе записи всего одну миниатюру. Если картинки оотсутствуют, то будет возвращена пустая строка.

Следующим шаблоном будет шаблон для lite режима. Lite режим - это использование шаблона lite для анонсов и разбивка на страницы по 1000 записей на страницу. Предназначен такой режим для предовращения дублирования контента, которое происходит при классических анонсах, что может негативно влиять на ранжирование поисковыми машинами.
*/

content.excerpts.lite = [
			<h1>$lang.posts</h1>
			<ul>
				$excerpt = [<li><a href="$post.link" title="$lang.permalink $post.title">$post.title</a></li>]
			</ul>
]

/*
Как видим шаблон простой и включает в себя один вложенный шаблон $excerpt - элемент списка. Внутри $excerpt доступны все теги $post.*

В секции content нам осталось описать еще два шаблона - navi и admin. Шаблон navi предназначен для постраничной навигации, зададим его:
*/

content.navi = [
		<div><ul class="pagination" itemscope itemtype="http://schema.org/SiteNavigationElement">
			$prev = [$link]
			$next = [$link]
			$link = [<li><a href="$link" itemprop="url name">$page</a></li>]
			$current = [<li class="active" itemprop="name">$page</li>]
			$divider = [ ]
 </ul></div>
 ]

/*
Как видно, в шаблоне navi описаны 4 вложенных шаблона, а именно

$prev - шаблон для ссылки на предыдущую страницу. Устарел и не используется.
$next - шаблон ссылки на следующую страницу. Устарел и не используется как и шаблон $prev. Шаблоны оставлены для обратной совместимости.
$link - шаблон одной ссылки
$current - ссылка на текущую страницу, в данном случае ссылка отсутствует - только номер
$divider - разделитель между ссылками

В шаблоне $link доступны следующие теги для ее формирования:
$link - полный адрес страницы, включая адрес сайта
$url - адрес страницы без адреса сайта
$page - номер страницы, цифра

Шаблоны $prev и $next используются редко, так как могут выводит всего одну/две ссылки ранее/позже, что при большом количестве страниц очень неэфективно. В настоящий момент выводится целая полоска со ссылками на номера страниц. Поэтому вы можете не описывать шаблоны $prevи $next, они оставлены больше по историчиским причинам.

Остался последний шаблон в секции content - admin, вот его сейчас и опишим:
*/

content.admin = [
$tableclass = [table table-bordered]

$editor = [<div class="form-group"><label for="editor-$name">$lang.$name:</label>
<textarea class="form-control" name="$name" id="editor-$name">$value</textarea></div>]

$text = [<div class="form-group"><label for="text-$name">$lang.$name</label>
<input type="text" class="form-control" name="$name" id="text-$name" value="$value" /></div>]

$password = [<div class="form-group"><label for="password-$name">$lang.$name</label>
<input type="password" class="form-control" name="$name" id="password-$name" value="$value" /></div>]

$upload = [<div class="form-group"><label for="file-$name">$lang.$name</label>
<input type="file" name="$name" id="file-$name" /></div>]

$checkbox= [<div class="checkbox"><label>
<input type="checkbox" name="$name" id="checkbox-$name" $value />
$lang.$name</label></div>]

$combo = [<div class="form-group"><label for="combo-$name">$lang.$name:</label>
<select class="form-control" name="$name" id="combo-$name">$value</select></div>]

$radioitem = [<div class="radio"><label><input type="radio" name="$name" id="radio_$name_$index" value="$index" $checked />$value</label></div>]

$radio = [<div><h4>$lang.$name:</h4>$value</div>]

$hidden = [<input type="hidden" name="$name" id="hidden-$name" value="$value" />]

$button =   [<button type="submit" name="$name" id="submitbutton-$name" class="btn btn-default">$lang.$name</button>]

$submit =   [<div class="text-center"><div class="center-block"><button type="submit" name="$name" id="submitbutton-$name" class="btn btn-default">$lang.$name</button></div></div>]

$form = [<h4>$formtitle</h4>
<form action="" method="post" role="form">
$items
[submit=update]
</form>]
]

/*
Шаблон admin предназначен длягенерации форм в админке. Перечислим их

$text - шаблон однострочного редактора
$editor - шаблон многострочного редактора
$checkbox - шаблон чекбокса
$combo - шаблон комбобокса
$hidden - поле hidden, для упрощения генерации
$button - шаблон кнопки отправки формы
$submit - шаблон кнопки отправки формы, выровненный по центру
$form - шаблон формы
$tableclass - класс таблиц с рамочками, в фреймворке bootstrap это будет [table table-bordered] Добавлен в версии 5.73

Все - мы закончили с тегом $template.content и его шаблонами

перейдем к сайдбарам. За сайдбар отвечает тег $template.sidebar - вы можете в шаблоне полной страницы проставить несколько тегов $template.sidebar и таким образом мы получим несколько сайдбаров. Как же адресовать конкретный шаблон сайдбара? Нумерация сайдбаров идет сверху вниз по мере нахождения в шаблоне полной страницы тегов $template.sidebar. Таким образом первый встретившийся тег $template.sidebar будет означать объявление 0-го сайдбара. В движке есть теги вида $template.sidebar0, $template.sidebar1, $template.sidebar2, которые однозначно задают номер сайдбара. $template.sidebar является синонимом $template.sidebar0. В шаблоне всей страницы вы можете использовать только тег $template.sidebar,  без указания индексов, но в объявлении вы обязаны задать номер декларируемого сайдбара.

В каждом сайдбаре обязан быть шаблон $widget - виджет. Если не будет объявлен один из стандартных шаблонов виджетов, то будет использоваться шаблон по умолчанию для виджета $widget, поэтому его наличие является обязательным. Вы можете не задавать другие шаблоны, но шаблон $widget вы обязаны задать. Более того, декларация шаблона widget автоматически перезаписывает все остальные шаблоны в этом сайдбаре - обратите на это внимание. Поэтому следует всегда первым декларировать шаблон по умолчанию widget, а потом все остальные виджеты. Есть два исключения, которые шаблон widget не перезаписывает, если они уже объявлены или унаследованы:
1. sidebar.posts.item - шаблон элемента списка для свежих записей
2. sidebar.comments.item - шаблон элемента списка свежих комментариев.

Это потому, что эти два шаблона используют сильно отличающиеся теги от стандартных виджетов, как например $post и $comment, которые не доступны в любом другом виджете.

Объявим первый сайдбар, а внутри него шаблон виджета по умолчанию:
*/

$template.sidebar = [
  $widget = [
  <div class="panel panel-default">
      <div class="panel-heading" id="widget-heading-$id">
      <h4 class="panel-title widget-title" data-model="widget-collapse">$title</h4>
      </div>
      
<div class="collapse in" id="widget-content-$id" aria-labelledby="widget-heading-$id">
      <div class="panel-body">
          $items = [
    <ul>
       $item = [<li><a href="$link" title="$title">$icon$text</a>
$subcount = [<strong>($itemscount)</strong>]
$subitems = [<ul>$item</ul>]
</li>]
    </ul>
    ]
        </div></div>
    </div>
]
]

/*
В объявлении виджета мы встречаем несколько вложенных объявлений, эти объявления для каждого типа виджетов являются практически стандартными. Перечислим их:

$title - название виджета
$items - шаблон списка
$item - шаблон элемента списка
$subcount - шаблон количества, например записей в рубрике
$subitems - шаблон вложенного списка

Видно, что все три шаблона вложены друг в друга. Если виджет в настройках является аяксовым, то используется только верхний шаблон. Для генерации контента виджета используются как раз шаблоны $items	, $item, $subitems. 

Обратим внимание на теги внутри шаблона $item:

$link - полный адрес ссылки
$title - описание, текст для атрибута title
$rel - текст для адрибута rel
$icon - не обязательный html иконки, если есть
$text - текст ссылки
$subcount html количества, например записей в рубрике
$itemscount - цифра количества , например количество записей в рубрике
$subitems - html вложенного списка, может быть другой текст

Как правило значения $title и $text совпадают, но могут и отличаться. Для генерации вложенного списка $subitms в для шаблона списка используется шаблон $item. $subitems является аналогом тега $items.

В шаблоне сайдбара можно задавать шаблоны стандартных виджетов. Перечислим их:

$widget - шаблон виджета по умолчанию
$categories - рубрики
$tags - метки
$archives - архив
$links - ссылки
$posts - свежие записи
$comments - свежие комментарии
$friends - мои друзя
$meta - мета

Магия Litepublisher заключается в том, что на объявлении виджета по умолчанию ($widget) можно остановиться при разработке новой темы. Последующие объявления шаблонов  виджетов будут лишь переписывать шаблон из виджета по умолчанию. Правило действует только на один сайдбар - для следующих сайдбаров обязательно декларируйте шаблон виджета по умолчанию. Также шаблон виджета по умлочанию должен быть первым в объявлении среди других виджетов. Шаблон вижета по умолчанию перезаписывает собой все шаблоны своего сайдбара - именно поэтому советуем его ставить первым.

Мы старались сделать управление шаблонами движка максимально простыми и универсальными, но для реальных задач универсальность противоречит тонкой настройке. Так например шаблон $item виджетов свежих записей, свежих комментариев не совпадают с виджетом по умолчанию. Задекларируем их:
*/

sidebar.posts.item     = [<li><a href="$post.link" rel="bookmark" title="$lang.permalink $post.title">$post.title</a></li>]
sidebar.comments.item = [<li><a href=" $link#comment-$id" title="$name $onrecent $title">$name $onrecent $title</a>: $content...</li>]
sidebar.meta.item      = [<li><a $class href="$link" title="$title">$icon$text</a>$subitems</li>]

/*
Мы объявили 3 шаблона: элемент списка для свежих записей, элемент списка для свежих комментариев и элемент списка мета. В этих шаблонах используются неизвестные ранее теги, к которым нужны пояснения. Но прежде хотелось бы разъяснить следующий момент: мы не прописывали шаблон всего виджета целиком, потому, что в этом нет необходимости - он совпадает с шаблоном виджета по умолчанию. Если была бы необходимость задать шаблон, то сделать этом можно так:

sidebar.posts = [... шаблон всего виджета свежих записей ...]
sidebar.posts.items = [... шаблон списка виджета свежих записей ...]

Ну и так далее - можно прописать любой вложенный шаблон любого вижета.

 Разберем какие же теги использовалис для вилжета свежих записей. Это уже встречавшиейся ранее теги $post.link, $post.title. А встречались они ранее в шаблонах записи и анонсов. В шаблоне свежих записей доступен $post со всеми его свойствами, так что можно придумать весьма причудливый контент для этого виджета.

В шаблоне свежих коменнтариев доступны следующие теги:

$id - уникальный id (число) комментария
$author - уникальный id (число) комментатора
$parent - уникальный id (число) родительского комментария, равно 0
$content - отфильтрованный текст комментария полностью
$text - краткая цитата из текста комментария, максимум 120 символов (для текста на русском в utf8 в два раза меньше)
$name - имя комментатора
$email - E-Mail комментатора
$url - адрес сайта комментатора
$post - уникальный id записи, где комментарий
$title - заголовок записи, где комментарий
$link - адрес записи, включая адрес сайта
$posturl - адрес записи, без адреса сайта
$onrecent - переведенная на установленный язык фраза "комментарий на"

В виджете мета мы встретили особый тег - $class, который отсутствует в д других виджетах.  Это html класс ссылки.  Чтобы задать html класс сылки в виджете мета есть дополнительный шаблон $classes, которого больше ни у кого нет. sidebar.meta.classes  - это полный путь к этому шаблону, который содержит список классов. Этот шаблон не является html шаблоном, как другие. В нем находятся имена классов в формате тип_ссылки=название_html_класса разделенными запятыми. Если класс не задан, то в сгенерированном html виджета не будет класса у ссылки. Известны следующие типы ссылок:

rss - ссылка на RSS записей
comments - ссылка на RSS комментариев
media - ссылка на RSS файлов
foaf - xml документ FOAF
profile - ссылка на профиль
sitemap- ссылка на карту сайта

 Зададим шаблон для классов:
*/

sidebar.meta.classes = [rss=rss,comments=rss-comments,foaf=foaf]

/*
Мы закончили с шаблонами первого сайдбара, перейдем ко второму и сразу объявим шаблон виджета по умолчанию sidebar1.widget . После чего объявим шаблоны для свежих записей и комментариев. Для чего делать последнее, если мы объявили шаблон для виджета по умолчанию? Потому, что эти шаблоны отличаются  от шаблона по умолчанию и эта тема является темой по умолчанию и ей (теме) ниоткуда взять  шаблоны.
*/

sidebar1.widget = [
  <a href="#widget-content-$id" id="widget-title-$id" class="btn btn-default dropdown-toggle widget-button" data-toggle="dropdown" data-model="dropdown" data-placement="top" data-target="#widget-content-$id" aria-haspopup="true" aria-expanded="false"> $title <span class="caret"></span></a>
  <div id="widget-content-$id" class="footer-widget-content" aria-labelledby="widget-title-$id">
$items = [          <ul class="dropdown-menu" role="menu">
$item = [<li><a href="$link" title="$title">$icon$text</a>
$subcount = [<em>($itemscount)</em>]
$subitems = [<ul>$item</ul>]
</li>]
</ul>]
</div>]

sidebar1.posts.item    = [<li><a href="$post.link" rel="bookmark" title="$lang.permalink $post.title">$post.title</a></li>]
sidebar1.comments.item = [<li><a href="$link#comment-$id" title="$name $onrecent $title">$name $onrecent $title</a>: $content...</li>]
sidebar1.meta.item     = [<li><a href="$link" title="$title"><span $class aria-hidden="true"></span> $text</a>$subitems</li>]
sidebar1.meta.classes  = [rss=fa fa-rss,comments=fa fa-comments,foaf=fa fa-group]

/*
Остаются еще два глобальных шаблона для поддержки аяксовых виджетов.  В Litepublisher есть 2 типа аяксовых виджета на front-end стороне: обыкновенный ajax контент получаемый http запросом и псевдо-аяксовый, контент которого извлекается из html комментария.

Эти два шаблона определяют html код, который будет вставлен вместо заголовка виджета ($title) и связан с javascript библиотекой LitePublisher, а именно скрипты в файле js/litepublisher/widgets.js. Первый шаблон $ajaxwidget является шаблоном для подгружаемого виджета, второй $inlinewidget является имитацией аяксового виджета и его контент не подгружается отдельным http запросом, а вставлен в html комментарий страницы, тем самым уменьшая нагрузку на сервер и ускоряя работу сайта, так как в отличии от $ajaxwidget контент $inlinewidget появляется мгновенно. Внутри этих двух шаблонов доступны следующие теги:

$id - id виджета, целое число
$sidebar - номер сайдбара, целое число
$title - заголовок виджета
*/

$template.ajaxwidget = [<span class="widget-ajax" data-widget="{&quot;id&quot;:&quot;$id&quot;,&quot;sidebar&quot;:&quot;$sidebar&quot;,&quot;type&quot;:&quot;ajax&quot;}">$title</span>]

$template.inlinewidget = [<span class="widget-inline" data-widget="{&quot;id&quot;:&quot;$id&quot;,&quot;sidebar&quot;:&quot;$sidebar&quot;,&quot;type&quot;:&quot;inline&quot;}">$title</span>]

/*
Все, описание шаблонов виджетов закончено.  На этом тема закончена. Все шаблоны движка полностью описаны. Одновременно вы имеете готовую рабочую тему и документацию к ней в одном файле. 

6. Дополнительные шаблоны $custom.

 Иногда возникает потребность в тегах, которые отсутствуют в формате темы. LitePublisher предоставляет такую возможность - добавление своих собственных тегов. Эти теги имеют вид $custom.* и могут использоваться в любом месте темы. Создадим для примера тег:
$custom.test = [<h2>Мой собственный тег  test</h2>]

Если вы добавите в свою тему строку выше, то сможете использовать $custom.test в любом месте темы.

 Абстрактные примеры мало интересны. В самом начале, при разборе шаблона всей страницы из файла index.tml, мы упомянули о двух $custom тегах, сейчас самое время детально их рассмотреть. Первый из них - это $custom.cssfile- один из css файлов темы. Значение по умолчанию будет default. Добавим этот тег:
*/

$custom.cssfile = [default]

/*
Еще раз посмотрим на строку в файле index.tml
    <link rel="stylesheet" href="$template.url/css/$custom.cssfile.min.css?v=$template.cssmerger" type="text/css" media="all" />
    
    После подстановки $custom.cssfile значением default получим:
        <link rel="stylesheet" href="$template.url/css/default.min.css?v=$template.cssmerger" type="text/css" media="all" />
        
        Окончательный результат будет примерно таким:
            <link rel="stylesheet" href="http://litepublisher.ru/themes/default/css/default.min.css?v=57" type="text/css" media="all" />
            
            Если мы будем менять значение тега $custom.cssfile то получим подключение других css файлов темы. Собственно, одно единственное значение тега $custom.cssfile совсем неинтересно - подставить default и не париться. Нужна админка для управления этим тегом и заморачиваться с программированием такой админки нет желания и времени. Litepublisher предоставляет такую возможность - админка для $custom тегов. Для этого к тегу достаточно добавить .admin следующим образом: $custom.cssfile.admin = [...] и не отходя от кассы, добавим в тему:
*/

$custom.cssfile.admin = [
$title = [Вариант оформления темы (один из файлов css темы)]
$type = [combo]
$values = [default,cerulean,cosmo,cyborg,darkly,flatly,journal,lumen,paper,readable,sandstone,simplex,slate,spacelab,superhero,united,yeti]
]

/*
Внутри .admin находятся 3 обязательных тега, которые надо задать:
$title - заголовок для формы в админке, в данном  случае это Вариант оформления темы (один из файлов css темы)
$type -тип контрола в форме, для нашего тега это combo. Возможны только следующие значения:
  text - однострочный редактор, $values не требуется
  editor - многострочный редактор, $values не требуется
  combo - комбобокс, требуется для него еще тег $values
  radio - радиокнопки, требуется для них $values

$values задаётся простым перечислением через запятую текстов, которые можно выбрать в комбобоксе или радиокнопками. В нашем теге это список из 17 файлов через запятую.

Таким образом мы описали админку для кастомного тега. Где ее можно найти? Она находится в редакторе вида на вкладке custom. Одно из важных свойств $custom тегов - текущее значение хранится в данных вида. Если одна и таже тема используется в нескольких видах (обычно это так и есть - одна тема во всех видах), то значение тегов $custom можно задавать индивидуально для каждого вида. Первоначальное значение берется как это прописано в теме. К примеру, для нашего $custom.cssfile - это default. Значения всех $custom тегов сбрасывается при смене темы в виде.

Аналогично добавим тег $custom.mainsidebar с двумя возможными значениями left,right
*/

$custom.mainsidebar = [left]
$custom.mainsidebar.admin = [
$title = [сайдбар слева или справа]
$type = [radio]
$values = [left,right]
]

/*
Админка немного отличается: $type = radio, что означает радиокнопки и всего два значения.

На этом можно остановиться, но нам хотелось бы рассказать, как при помощи всего одного css класса можно поменять местами сайдбар  контент.. Собственно, верстка, css трюки выходят за рамки описания формата темы. Вот кусок шаблона из index.tml

          <div class="container-fluid section"><div class="row sidebar-$custom.mainsidebar">
                    <div class="col-sm-9 content" itemscope itemprop="mainContentOfPage">$template.content</div>
          <div class="col-sm-3 main-sidebar"><div class="panel-group" id="sidebar1" role="tablist" aria-multiselectable="true" itemscope itemtype="http://schema.org/WPSideBar">$template.sidebar</div></div>
</div></div>
Переключение положения сайдбара будет происходить при помощи классов sidebar-left и sidebar-right. Если никак не прописать класс sidebar-right в стилях, то сайдбар будет справа, как это видно из верстки. Задача сводится к тому. чтобы при помощи sidebar-left поставить слева сайдбар, но при этом на мобильных устройствах сайдбар был бы под главным контентом. В bootstrap эта задача решается при помощи следующего css:

@media (min-width: 768px) {
  .sidebar-left > .content {
    left: 25%;
  }
  .sidebar-left > .main-sidebar {
    right: 75%;
  }
}

6. Теги $label.* служат для разметки в тексте страницы на этапе ее генерации. После генерации все $label.* будут удалены из страницы. Поэтому вы можете безопасно использовать любое количество $label.*. Это означает, что вы просто в любом месте любого шаблона можете написать $label.some (или другой $label.* тег) любое количество раз. После генерации страницы абсолютно все $label.* будут удалены из страницы. Возникает резонный вопрос - тогда зачем они вообще нужны, если будут все удалены? Ответ -сделать вставку html в указанном месте. Тег $label.* является таким инструментом. На jquery в браузере эта задача решается тривиально, но вот на стороне сервера, когда страница еще генерируется, то это сделать было бы сложно. Вероятно, можно в границах одной темы прийти к каким то соглашениям, чтобы упростить вставку дополнительного html. Но требуется универсальное средство, которое работало в любых шаблонах. $label.* решают эту задачу. Надо признаться, что введение в формат темы разметочных тегов $label далось нелегко, так как нарушает некую стройность концепции тегов движка.

 На сегодня используется только один тег $label.homeimage - большая картинка на главной. Задача - добавить большую картинку на главную страницу после меню. Правильное решение было бы завести отдельный шаблон для главной страницы. В движке существует такое решение - шаблон index.home и все им могут воспользоваться. недостатки такого решения - если вносятся изменения в index.tml, то их придется синхронизировать в шаблоне index.home. Однажды может случиться, что вы забудете или допустите ошибку при очередной синхронизации.

$label.* помогут решить эту задачу имея всего один общий шаблон index.tml в котором достаточно указать место для большой картинки. Вставим туда $label.homeimage Когда будет генирироваться главная страница, то модуль главной страницы обработает этот тег, а на остальных страницах этот тег будет удален. Получается вот такой трюк.

Надо заметить, что в модуле главной страницы уже предусмотрена обработка $label.homeimage и в движке пока больше нет других обработчиков $label.* (возможно они появятся в последующих версиях), поэтому если вы просто расставите $label.* по шаблонам, то это не будет иметь ни какого эфекта. Причина банальна - нет обработчиков дя этих тегов и все они будут удалены из текста страницы.

Полное окончание темы. Все. Удачных разработок!
*/